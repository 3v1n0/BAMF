=== modified file 'configure.in'
--- old/configure.in	2012-08-10 10:10:12 +0000
+++ new/configure.in	2012-08-10 18:06:55 +0000
@@ -121,6 +121,14 @@
 GTK_DOC_CHECK(1.0)
 
 ###########################
+# libunity_webapps
+###########################
+PKG_CHECK_MODULES(LIBUNITY_WEBAPPS, libunity_webapps-0.2)
+
+AC_SUBST(LIBUNITY_WEBAPPS_CFLAGS)
+AC_SUBST(LIBUNITY_WEBAPPS_LIBS)
+
+###########################
 # Headless tests
 ###########################
 AC_ARG_ENABLE([headless-tests],

=== modified file 'lib/libbamf/bamf-application.c'
--- old/lib/libbamf/bamf-application.c	2012-07-01 18:13:55 +0000
+++ new/lib/libbamf/bamf-application.c	2012-08-10 17:59:26 +0000
@@ -68,9 +68,41 @@
   gchar           *application_type;
   gchar           *desktop_file;
   GList           *cached_xids;
-  int              show_stubs;
+  gchar           **cached_mimes;
+  gboolean        mimes_initialized;
+  int             show_stubs;
 };
 
+gchar **
+bamf_application_get_dnd_mimes (BamfApplication *application)
+{
+  GError *error = NULL;
+  gchar **mimes = NULL;
+
+  if (application->priv->mimes_initialized)
+    return g_strdupv (application->priv->cached_mimes);
+
+  if (!_bamf_view_remote_ready (BAMF_VIEW (application)))
+    return NULL;
+
+  if (!dbus_g_proxy_call (application->priv->proxy,
+                          "DndMimes",
+                          &error,
+                          G_TYPE_INVALID,
+                          G_TYPE_STRV, &mimes,
+                          G_TYPE_INVALID))
+    {
+      g_warning ("Failed to fetch mimes: %s", error->message);
+      g_error_free (error);
+
+      return NULL;
+    }
+  application->priv->mimes_initialized = TRUE;
+  application->priv->cached_mimes = g_strdupv (mimes);
+
+  return mimes;
+}
+
 /**
  * bamf_application_get_desktop_file:
  * @application: a #BamfApplication
@@ -119,6 +151,38 @@
   return file;
 }
 
+gboolean
+bamf_application_get_application_menu (BamfApplication *application,
+                                      gchar **name,
+                                      gchar **object_path)
+{
+  BamfApplicationPrivate *priv;
+  GError *error = NULL;
+  
+  g_return_val_if_fail (BAMF_IS_APPLICATION (application), FALSE);
+  
+  priv = application->priv;
+  
+  if (!_bamf_view_remote_ready (BAMF_VIEW (application)))
+    return FALSE;
+
+  if (!dbus_g_proxy_call (priv->proxy,
+                          "ApplicationMenu",
+                          &error,
+                          G_TYPE_INVALID,
+                          G_TYPE_STRING, name,
+                         G_TYPE_STRING, object_path,
+                          G_TYPE_INVALID))
+    {
+      g_warning ("Failed to fetch application menu path: %s", error->message);
+      g_error_free (error);
+      
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
 /**
  * bamf_application_get_applicaton_type:
  * @application: a #BamfApplication
@@ -287,6 +351,16 @@
 }
 
 static void
+bamf_application_on_dnd_mimes_changed (DBusGProxy *proxy, const gchar *const *mimes, BamfApplication *self)
+{
+  if (self->priv->cached_mimes)
+    g_strfreev (self->priv->cached_mimes);
+
+  self->priv->cached_mimes = g_strdupv ((gchar**)mimes);
+  self->priv->mimes_initialized = TRUE;
+}
+
+static void
 bamf_application_on_window_added (DBusGProxy *proxy, char *path, BamfApplication *self)
 {
   BamfView *view;
@@ -330,6 +404,40 @@
     }
 }
 
+BamfView *
+bamf_application_get_focus_child (BamfApplication *application)
+{
+  BamfApplicationPrivate *priv;
+  BamfView *ret;
+  gchar *path;
+  GError *error = NULL;
+
+  g_return_val_if_fail (BAMF_IS_APPLICATION (application), FALSE);
+  priv = application->priv;
+  
+  if (!_bamf_view_remote_ready (BAMF_VIEW (application)))
+    return NULL;
+
+  if (!dbus_g_proxy_call (priv->proxy,
+                          "FocusChild",
+                          &error,
+                          G_TYPE_INVALID,
+                          G_TYPE_STRING, &path,
+                          G_TYPE_INVALID))
+    {
+      g_warning ("Failed to fetch focus xids: %s", error->message);
+      g_error_free (error);
+      
+      return NULL;
+    }
+
+  ret = _bamf_factory_view_for_path (_bamf_factory_get_default (), path);
+  
+  g_free (path);
+  
+  return ret;
+}
+
 GList *
 _bamf_application_get_cached_xids (BamfApplication *self)
 {
@@ -358,6 +466,10 @@
                                  "WindowRemoved",
                                  (GCallback) bamf_application_on_window_removed,
                                  self);
+  dbus_g_proxy_disconnect_signal (priv->proxy,
+				  "DndMimesChanged",
+				  (GCallback) bamf_application_on_dnd_mimes_changed,
+				  self);
 
   g_object_unref (priv->proxy);
   priv->proxy = NULL;
@@ -389,7 +501,7 @@
       g_list_free (priv->cached_xids);
       priv->cached_xids = NULL;
     }
-
+  
   bamf_application_unset_proxy (self);
 
   if (G_OBJECT_CLASS (bamf_application_parent_class)->dispose)
@@ -406,6 +518,7 @@
   priv = self->priv;
 
   bamf_application_unset_proxy (self);
+
   priv->proxy = dbus_g_proxy_new_for_name (priv->connection,
                                            "org.ayatana.bamf",
                                            path,
@@ -426,6 +539,11 @@
                            G_TYPE_STRING,
                            G_TYPE_INVALID);
 
+  dbus_g_proxy_add_signal (priv->proxy,
+                           "DndMimesChanged",
+                           G_TYPE_STRV,
+                           G_TYPE_INVALID);
+
   dbus_g_proxy_connect_signal (priv->proxy,
                                "WindowAdded",
                                (GCallback) bamf_application_on_window_added,
@@ -438,6 +556,12 @@
                                self,
                                NULL);
 
+  dbus_g_proxy_connect_signal (priv->proxy,
+                               "DndMimesChanged",
+                               (GCallback) bamf_application_on_dnd_mimes_changed,
+                               self,
+                               NULL);
+
   GList *children, *l;
   children = bamf_view_get_children (view);
 

=== modified file 'lib/libbamf/bamf-application.h'
--- old/lib/libbamf/bamf-application.h	2012-07-01 18:13:55 +0000
+++ new/lib/libbamf/bamf-application.h	2012-08-10 18:00:17 +0000
@@ -79,12 +79,20 @@
 
 const gchar     * bamf_application_get_desktop_file     (BamfApplication *application);
 
+gchar ** bamf_application_get_dnd_mimes (BamfApplication *application);
+
 GList           * bamf_application_get_windows          (BamfApplication *application);
 
 GArray          * bamf_application_get_xids             (BamfApplication *application);
 
+BamfView * bamf_application_get_focus_child (BamfApplication *application);
+
 gboolean          bamf_application_get_show_menu_stubs  (BamfApplication *application);
 
+gboolean bamf_application_get_application_menu (BamfApplication *application,
+						gchar **name,
+						gchar **object_path);
+
 G_END_DECLS
 
 #endif

=== modified file 'lib/libbamf/bamf-factory.c'
--- old/lib/libbamf/bamf-factory.c	2012-06-13 14:03:31 +0000
+++ new/lib/libbamf/bamf-factory.c	2012-08-10 17:55:34 +0000
@@ -41,6 +41,7 @@
 #include "bamf-application.h"
 #include "bamf-application-private.h"
 #include "bamf-indicator.h"
+#include "bamf-tab.h"
 
 #include <dbus/dbus.h>
 #include <dbus/dbus-glib.h>
@@ -184,6 +185,10 @@
         {
           factory_type = BAMF_FACTORY_VIEW;
         }
+      else if (g_strcmp0 (type, "tab") == 0)
+	{
+	  factory_type = BAMF_FACTORY_TAB;
+	}
     }
 
   return factory_type;
@@ -248,8 +253,12 @@
     case BAMF_FACTORY_INDICATOR:
       view = BAMF_VIEW (bamf_indicator_new (path));
       break;
+    case BAMF_FACTORY_TAB:
+      view = BAMF_VIEW (bamf_tab_new (path));
+      break;
     case BAMF_FACTORY_NONE:
       view = NULL;
+      break;
   }
 
   created = TRUE;

=== modified file 'lib/libbamf/bamf-factory.h'
--- old/lib/libbamf/bamf-factory.h	2012-05-24 20:25:51 +0000
+++ new/lib/libbamf/bamf-factory.h	2012-08-10 17:55:34 +0000
@@ -60,6 +60,7 @@
   BAMF_FACTORY_WINDOW,
   BAMF_FACTORY_APPLICATION,
   BAMF_FACTORY_INDICATOR,
+  BAMF_FACTORY_TAB,
   BAMF_FACTORY_NONE
 } BamfFactoryViewType;
 

=== modified file 'lib/libbamf/bamf-marshal.list'
--- old/lib/libbamf/bamf-marshal.list	2012-01-10 15:06:05 +0000
+++ new/lib/libbamf/bamf-marshal.list	2012-08-10 17:55:50 +0000
@@ -21,3 +21,4 @@
 VOID: STRING, STRING, STRING
 VOID: OBJECT, OBJECT
 VOID: INT, INT
+VOID: STRING, BOXED, POINTER

=== modified file 'lib/libbamf/bamf-tab-source.h'
--- old/lib/libbamf/bamf-tab-source.h	2010-05-25 13:14:11 +0000
+++ new/lib/libbamf/bamf-tab-source.h	2012-08-10 17:55:58 +0000
@@ -27,6 +27,7 @@
 #define __BAMF_TAB_SOURCE_H__
 
 #include <glib-object.h>
+#include "bamf-tab.h"
 
 G_BEGIN_DECLS
 

=== modified file 'lib/libbamf/bamf-tab.c'
--- old/lib/libbamf/bamf-tab.c	2012-05-24 20:25:51 +0000
+++ new/lib/libbamf/bamf-tab.c	2012-08-10 17:55:58 +0000
@@ -2,7 +2,8 @@
  * bamf-tab.c
  * This file is part of BAMF
  *
- * Copyright (C) 2010 - Jason Smith
+ * Copyright (C) 2012 Canonical LTD
+ * Authors: Robert Carr <racarr@canonical.com>
  *
  * BAMF is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,6 +23,11 @@
 
 #include "bamf-tab.h"
 #include "bamf-marshal.h"
+#include "bamf-view-private.h"
+
+#include <dbus/dbus.h>
+#include <dbus/dbus-glib.h>
+#include <dbus/dbus-glib-lowlevel.h>
 
 
 #define BAMF_TAB_GET_PRIVATE(object)(G_TYPE_INSTANCE_GET_PRIVATE((object), BAMF_TYPE_TAB, BamfTabPrivate))
@@ -29,104 +35,204 @@
 enum
 {
   PROP_0,
-  
-  PROP_ID,
-  PROP_URI,
-  PROP_PREVIEW,
+  PROP_LOCATION,
+  PROP_DESKTOP_ID,
+  PROP_XID,
+  PROP_IS_FOREGROUND_TAB
 };
+    
 
 enum
 {
-  URI_CHANGED,
-  PREVIEW_UPDATED,
-
+  FILL,
   LAST_SIGNAL,
 };
 
-static guint tab_signals[LAST_SIGNAL] = { 0 };
+//static guint tab_signals[LAST_SIGNAL] = { 0 };
 
 struct _BamfTabPrivate
 {
-  gchar *uri;
-  gchar *preview_uri;
-  gchar *id;
+  DBusGConnection *connection;
+  DBusGProxy *tab_proxy;
+  DBusGProxy *properties_proxy;
+  
+  gchar *location;
+  gchar *desktop_name;
+  guint64 xid;
+  gboolean is_foreground;
 };
 
 G_DEFINE_TYPE (BamfTab, bamf_tab, BAMF_TYPE_VIEW)
 
-gchar *
-bamf_tab_get_id (BamfTab *tab)
-{
-  g_return_val_if_fail (BAMF_IS_TAB (tab), NULL);
-  
-  return tab->priv->id;
-}
-
-gchar *
-bamf_tab_get_preview (BamfTab *tab)
-{
-  g_return_val_if_fail (BAMF_IS_TAB (tab), NULL);
-  
-  return tab->priv->preview_uri;
-}
-
-void
-bamf_tab_set_preview (BamfTab *tab, gchar *uri)
-{
-  g_return_if_fail (BAMF_IS_TAB (tab));
-  
-  tab->priv->preview_uri = uri;
-}
-
-gchar *
-bamf_tab_get_uri (BamfTab *tab)
-{
-  g_return_val_if_fail (BAMF_IS_TAB (tab), NULL);
-  
-  return tab->priv->uri;
-}
-
-void
-bamf_tab_set_uri (BamfTab *tab, gchar *uri)
-{
-  gchar *old;
-
-  g_return_if_fail (BAMF_IS_TAB (tab));
-  
-  old = tab->priv->uri;
-  tab->priv->uri = uri;
-
-  g_signal_emit (tab, tab_signals[URI_CHANGED], 0, old, uri);  
-}
-
-void bamf_tab_show (BamfTab *self)
-{
-  if (BAMF_TAB_GET_CLASS (self)->show)
-    BAMF_TAB_GET_CLASS (self)->show (self);
-  else
-    g_warning ("Default tab class implementation cannot perform show!\n");
-}
+static void
+bamf_tab_got_properties (DBusGProxy *proxy,
+			 DBusGProxyCall *call_id,
+			 void *user_data)
+{
+  BamfTab *self;
+  GHashTable *properties;
+  GError *error;
+  GHashTableIter iter;
+  gpointer key, value;
+
+  
+  self = BAMF_TAB (user_data);
+  
+  error = NULL;
+  
+  dbus_g_proxy_end_call (proxy, call_id, &error,
+			 dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), &properties,
+			 G_TYPE_INVALID);
+
+  if (error != NULL)
+    {
+      g_critical ("Failed to fetch BamfTab properties: %s", error->message);
+      g_error_free (error);
+      
+      return;
+    }
+  
+  if (properties == NULL)
+    {
+      return;
+    }
+  
+  g_hash_table_iter_init (&iter, properties);
+  
+  while (g_hash_table_iter_next (&iter, &key, &value))
+    {
+      g_object_set_property (G_OBJECT (self), (const gchar *)key, (GValue *)value);
+    }
+
+}
+
+
+static void
+bamf_tab_fetch_properties (BamfTab *self)
+{
+  dbus_g_proxy_begin_call (self->priv->properties_proxy,
+			   "GetAll", 
+			   bamf_tab_got_properties,
+			   g_object_ref (G_OBJECT (self)),
+			   (GDestroyNotify)g_object_unref,
+			   G_TYPE_STRING, "org.ayatana.bamf.tab",
+			   G_TYPE_INVALID);
+  
+}
+
+static void
+bamf_tab_on_properties_changed (DBusGProxy *proxy,
+				const gchar *interface_name,
+				GHashTable *changed_properties,
+				const gchar **invalidated_properties,
+				gpointer user_data)
+{
+  BamfTab *self;
+  GHashTableIter iter;
+  gpointer key, value;
+  guint i, len;
+
+  if (g_strcmp0 (interface_name, "org.ayatana.bamf.tab") != 0)
+    {
+      return;
+    }
+  
+  self = (BamfTab *)user_data;
+  
+  g_hash_table_iter_init (&iter, changed_properties);
+  
+  while (g_hash_table_iter_next (&iter, &key, &value))
+    {
+      g_object_set_property (G_OBJECT (self), (const gchar *)key, (GValue *)value);
+    }
+  
+  if (invalidated_properties == NULL)
+    {
+      return;
+    }
+  
+  len = g_strv_length ((gchar **)invalidated_properties);
+  for (i = 0; i < len; i++)
+    {
+      g_critical("Invalidated prop: %s\n", invalidated_properties[i]);
+    }
+}
+
+static void
+bamf_tab_set_path (BamfView *view, const gchar *path)
+{
+  BamfTab *self;
+  
+  self = BAMF_TAB (view);
+  
+  self->priv->tab_proxy = dbus_g_proxy_new_for_name (self->priv->connection,
+						 "org.ayatana.bamf",
+						 path,
+						 "org.ayatana.bamf.tab");
+  
+  if (self->priv->tab_proxy == NULL)
+    {
+      g_warning ("Unable to get org.ayatana.bamf.tab proxy: %s", path);
+      return;
+    }
+  
+  self->priv->properties_proxy = dbus_g_proxy_new_for_name (self->priv->connection,
+							    "org.ayatana.bamf",
+							    path,
+							    "org.freedesktop.DBus.Properties");
+
+  if (self->priv->properties_proxy == NULL)
+    {
+      g_warning ("Unable to get org.freedesktop.DBus.properties proxy on tab object: %s", path);
+      return;
+    }
+  
+  bamf_tab_fetch_properties (self);
+  
+  dbus_g_object_register_marshaller ((GClosureMarshal) _bamf_marshal_VOID__STRING_BOXED_POINTER,
+				     G_TYPE_NONE,
+				     G_TYPE_STRING,
+				     G_TYPE_BOXED,
+				     G_TYPE_STRV,
+				     G_TYPE_INVALID);
+  
+  dbus_g_proxy_add_signal (self->priv->properties_proxy,
+			   "PropertiesChanged",
+			   G_TYPE_STRING,
+			   dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE),
+			   G_TYPE_STRV,
+			   G_TYPE_INVALID);
+  dbus_g_proxy_connect_signal (self->priv->properties_proxy,
+			       "PropertiesChanged",
+			       (GCallback) bamf_tab_on_properties_changed,
+			       self,
+			       NULL);
+ }
 
 static void
 bamf_tab_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec)
 {
   BamfTab *self;
-
+  
   self = BAMF_TAB (object);
-
+  
   switch (property_id)
     {
-      case PROP_ID:
-        self->priv->id = g_value_dup_string (value);
-        break;
-      case PROP_URI:
-        bamf_tab_set_uri (self, g_value_dup_string (value));
-        break;
-      case PROP_PREVIEW:
-        bamf_tab_set_preview (self, g_value_dup_string (value));
-        break;
-      default:
-        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
+    case PROP_LOCATION:
+      self->priv->location = g_value_dup_string (value);
+      break;
+    case PROP_DESKTOP_ID:
+      g_return_if_fail (self->priv->desktop_name == NULL);
+      self->priv->desktop_name = g_value_dup_string (value);
+      break;
+    case PROP_XID:
+      self->priv->xid = g_value_get_uint64 (value);
+      break;
+    case PROP_IS_FOREGROUND_TAB:
+      self->priv->is_foreground = g_value_get_boolean (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
     }
 }
 
@@ -134,88 +240,269 @@
 bamf_tab_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec)
 {
   BamfTab *self;
-
+  
   self = BAMF_TAB (object);
-
+  
   switch (property_id)
     {
-      case PROP_ID:
-        g_value_set_string (value, bamf_tab_get_id (self));
-        break;
-      case PROP_URI:
-        g_value_set_string (value, bamf_tab_get_uri (self));
-        break;
-      case PROP_PREVIEW:
-        g_value_set_string (value, bamf_tab_get_preview (self));
-        break;
-
-      default:
-        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
+    case PROP_LOCATION:
+      g_value_set_string (value, self->priv->location);
+      break;
+    case PROP_DESKTOP_ID:
+      g_value_set_string (value, self->priv->desktop_name);
+      break;
+    case PROP_XID:
+      g_value_set_uint64 (value, self->priv->xid);
+      break;
+    case PROP_IS_FOREGROUND_TAB:
+      g_value_set_boolean (value, self->priv->is_foreground);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
     }
 }
 
 static void
-bamf_tab_constructed (GObject *object)
-{
-  G_OBJECT_CLASS (bamf_tab_parent_class)->constructed (object);
-}
-
-static void
 bamf_tab_dispose (GObject *object)
 {
-  G_OBJECT_CLASS (bamf_tab_parent_class)->dispose (object);
+  BamfTab *self;
+  
+  self = BAMF_TAB (object);
+  
+  if (self->priv->location != NULL)
+    {
+      g_free (self->priv->location);
+    }
+  if (self->priv->desktop_name != NULL)
+    {
+      g_free (self->priv->desktop_name);
+    }
+  if (self->priv->tab_proxy != NULL)
+    {
+      g_object_unref (G_OBJECT (self->priv->tab_proxy));
+    }
+  if (self->priv->properties_proxy != NULL)
+    {
+      dbus_g_proxy_disconnect_signal (self->priv->properties_proxy,
+				      "PropertiesChanged",
+				      (GCallback) bamf_tab_on_properties_changed,
+				      self);
+      g_object_unref (G_OBJECT (self->priv->properties_proxy));
+    }
+  if (G_OBJECT_CLASS (bamf_tab_parent_class)->dispose)
+    G_OBJECT_CLASS (bamf_tab_parent_class)->dispose (object);
 }
 
+
 static void
 bamf_tab_class_init (BamfTabClass *klass)
 {
   GParamSpec *pspec;
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-          
-  object_class->constructed = bamf_tab_constructed;
-  object_class->dispose = bamf_tab_dispose;
-  object_class->set_property = bamf_tab_set_property;
-  object_class->get_property = bamf_tab_get_property;
-
-  pspec = g_param_spec_string ("id", "id", "id", NULL, G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
-  g_object_class_install_property (object_class, PROP_ID, pspec);
-
-  pspec = g_param_spec_string ("uri", "uri", "uri", NULL, G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
-  g_object_class_install_property (object_class, PROP_URI, pspec);
-
-  pspec = g_param_spec_string ("preview", "preview", "preview", NULL, G_PARAM_READWRITE);
-  g_object_class_install_property (object_class, PROP_PREVIEW, pspec);
-
-  g_type_class_add_private (object_class, sizeof (BamfTabPrivate));
-  
-  tab_signals [URI_CHANGED] = 
-  	g_signal_new ("uri-changed",
-  	              G_OBJECT_CLASS_TYPE (klass),
-  	              G_SIGNAL_RUN_FIRST,
-  	              G_STRUCT_OFFSET (BamfTabClass, uri_changed),
-  	              NULL, NULL,
-  	              _bamf_marshal_VOID__STRING_STRING,
-  	              G_TYPE_NONE, 2, 
-  	              G_TYPE_STRING, G_TYPE_STRING);
-  
-  tab_signals [PREVIEW_UPDATED] = 
-  	g_signal_new ("preview-updated",
-  	              G_OBJECT_CLASS_TYPE (klass),
-  	              G_SIGNAL_RUN_FIRST,
-  	              G_STRUCT_OFFSET (BamfTabClass, preview_updated),
-  	              NULL, NULL,
-  	              g_cclosure_marshal_VOID__VOID,
-  	              G_TYPE_NONE, 0);
+  GObjectClass *obj_class = G_OBJECT_CLASS (klass);
+  BamfViewClass *view_class = BAMF_VIEW_CLASS (klass);
+  
+  obj_class->dispose = bamf_tab_dispose;
+  obj_class->get_property = bamf_tab_get_property;
+  obj_class->set_property = bamf_tab_set_property;
+  
+  view_class->set_path = bamf_tab_set_path;
+
+  pspec = g_param_spec_string("location", "Location", "The Current location of the remote Tab",
+			      NULL, G_PARAM_READWRITE);
+  g_object_class_install_property (obj_class, PROP_LOCATION, pspec);
+  
+  pspec = g_param_spec_string("desktop-id", "Desktop Name", "The Desktop ID assosciated with the application hosted in the remote Tab",
+			      NULL, G_PARAM_READWRITE);
+  g_object_class_install_property (obj_class, PROP_DESKTOP_ID, pspec);
+  
+  pspec = g_param_spec_uint64("xid", "xid", "XID for the toplevel window containing the remote Tab",
+			      0, G_MAXUINT64, 0, G_PARAM_READWRITE);
+  g_object_class_install_property (obj_class, PROP_XID, pspec);
+  
+  pspec = g_param_spec_boolean("is-foreground-tab", "Foreground tab", "Whether the tab is the foreground tab in it's toplevel container",
+			       FALSE, G_PARAM_READWRITE);
+  g_object_class_install_property (obj_class, PROP_IS_FOREGROUND_TAB, pspec);
+  
+  g_type_class_add_private (obj_class, sizeof(BamfTabPrivate));
+
 }
 
 static void
 bamf_tab_init (BamfTab *self)
 {
+  GError *error = NULL;
+  
   self->priv = BAMF_TAB_GET_PRIVATE (self);
+
+  self->priv->tab_proxy = NULL;
+  self->priv->properties_proxy = NULL;
+  
+  self->priv->location = NULL;
+  self->priv->desktop_name = NULL;
+  self->priv->xid = 0;
+
+  
+  self->priv->connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
+  
+  if (error != NULL)
+    {
+      g_warning ("Failed to open connection to bus: %s", error->message);
+      g_error_free (error);
+      
+      return;
+    }
 }
 
 BamfTab *
-bamf_tab_new (gchar *id, gchar *uri)
-{
-  return g_object_new (BAMF_TYPE_TAB, NULL);
+bamf_tab_new (const gchar *path)
+{
+  BamfTab *self;
+  
+  self = g_object_new (BAMF_TYPE_TAB, NULL);
+  
+  _bamf_view_set_path (BAMF_VIEW (self), path);
+  
+  return self;
+}
+
+gboolean
+bamf_tab_raise (BamfTab *self)
+{
+  GError *error;
+
+  g_return_val_if_fail (BAMF_IS_TAB (self), FALSE);
+  
+  if (!_bamf_view_remote_ready (BAMF_VIEW (self)))
+    return FALSE;
+  
+  error = NULL;
+  
+  if (!dbus_g_proxy_call (self->priv->tab_proxy,
+			  "Raise",
+			  &error,
+			  G_TYPE_INVALID))
+    {
+      g_warning ("Failed to invoke Raise method: %s", error->message);
+      g_error_free (error);
+      
+      return FALSE;
+    }
+  
+  return TRUE;
+}
+
+gboolean
+bamf_tab_close (BamfTab *self)
+{
+  GError *error;
+
+  g_return_val_if_fail (BAMF_IS_TAB (self), FALSE);
+  
+  if (!_bamf_view_remote_ready (BAMF_VIEW (self)))
+    return FALSE;
+  
+  error = NULL;
+  
+  if (!dbus_g_proxy_call (self->priv->tab_proxy,
+			  "Close",
+			  &error,
+			  G_TYPE_INVALID))
+    {
+      g_warning ("Failed to invoke Close method: %s", error->message);
+      g_error_free (error);
+      
+      return FALSE;
+    }
+  
+  return TRUE;
+}
+
+typedef struct _bamf_tab_preview_request_user_data {
+  BamfTab *self;
+  BamfTabPreviewReadyCallback callback;
+  gpointer user_data;
+} bamf_tab_preview_request_user_data;
+
+static void
+bamf_tab_on_preview_ready (DBusGProxy *proxy,
+			   DBusGProxyCall *call_id,
+			   gpointer user_data)
+{
+  BamfTab *self;
+  bamf_tab_preview_request_user_data *data;
+  gchar *preview_data = NULL;
+  GError *error;
+  
+  data = (bamf_tab_preview_request_user_data *)user_data;
+  self = data->self;
+  
+  error = NULL;
+  
+  dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_STRING,  &preview_data, G_TYPE_INVALID);
+  
+  if (error != NULL)
+    {
+      g_warning ("Error requesting BamfTab preview: %s", error->message);
+      g_error_free (error);
+      
+      return;
+    }
+  
+  data->callback (self, preview_data, data->user_data);
+  
+  g_free (preview_data);  
+}
+
+void
+bamf_tab_request_preview (BamfTab *self, BamfTabPreviewReadyCallback callback, gpointer user_data)
+{
+  bamf_tab_preview_request_user_data *data;
+
+  g_return_if_fail (BAMF_IS_TAB (self));
+  
+  data = g_malloc0 (sizeof (bamf_tab_preview_request_user_data));
+  data->self = self;
+  data->callback = callback;
+  data->user_data = user_data;
+  
+  dbus_g_proxy_begin_call (self->priv->tab_proxy,
+			   "RequestPreview",
+			   bamf_tab_on_preview_ready,
+			   data,
+			   (GDestroyNotify)g_free,
+			   G_TYPE_INVALID);  
+  
+ }
+ 
+ 
+const gchar *
+bamf_tab_get_location (BamfTab *self)
+{
+  g_return_val_if_fail (BAMF_IS_TAB (self), NULL);
+  
+  return self->priv->location;
+}
+
+const gchar *
+bamf_tab_get_desktop_name (BamfTab *self)
+{
+  g_return_val_if_fail (BAMF_IS_TAB (self), NULL);
+  
+  return self->priv->desktop_name;
+}
+
+guint64
+bamf_tab_get_xid (BamfTab *self)
+{
+  g_return_val_if_fail (BAMF_IS_TAB (self), 0);
+  
+  return self->priv->xid;
+}
+
+gboolean
+bamf_tab_get_is_foreground_tab (BamfTab *self)
+{
+  g_return_val_if_fail (BAMF_IS_TAB (self), 0);
+  
+  return self->priv->is_foreground;
 }

=== modified file 'lib/libbamf/bamf-tab.h'
--- old/lib/libbamf/bamf-tab.h	2010-11-18 09:36:18 +0000
+++ new/lib/libbamf/bamf-tab.h	2012-08-10 17:55:58 +0000
@@ -50,38 +50,25 @@
 
 struct _BamfTabClass {
   BamfViewClass parent_class;
-
-  void (*show) (BamfTab *self);
-
-  /*< signals >*/
-  void  (*uri_changed)      (char *old_uri, char *new_uri);
-  void  (*preview_updated)  (void);
-  
-  void (*_tab_padding1) (void);
-  void (*_tab_padding2) (void);
-  void (*_tab_padding3) (void);
-  void (*_tab_padding4) (void);
-  void (*_tab_padding5) (void);
-  void (*_tab_padding6) (void);
 };
 
+typedef void (*BamfTabPreviewReadyCallback) (BamfTab *self, const gchar *preview_data, gpointer user_data);
+
 GType bamf_tab_get_type (void) G_GNUC_CONST;
 
-gchar   * bamf_tab_get_id      (BamfTab *self);
-
-gchar   * bamf_tab_get_preview (BamfTab *self);
-
-void      bamf_tab_set_preview (BamfTab *self,
-                                gchar *uri);
-
-gchar   * bamf_tab_get_uri     (BamfTab *self);
-
-void      bamf_tab_set_uri     (BamfTab *self,
-                                gchar *uri);
-                                
-void      bamf_tab_show        (BamfTab *self);
-
-BamfTab * bamf_tab_new         (gchar *id, gchar *uri);
+BamfTab * bamf_tab_new         (const gchar *path);
+
+gboolean bamf_tab_raise        (BamfTab *self);
+gboolean bamf_tab_close        (BamfTab *self);
+void bamf_tab_request_preview (BamfTab *self, BamfTabPreviewReadyCallback callback, gpointer user_data);
+
+const gchar *bamf_tab_get_desktop_name (BamfTab *self);
+const gchar *bamf_tab_get_location (BamfTab *self);
+guint64 bamf_tab_get_xid (BamfTab *self);
+
+gboolean bamf_tab_get_is_foreground_tab (BamfTab *self);
+
+
 
 
 G_END_DECLS

=== modified file 'lib/libbamf/bamf-view.c'
--- old/lib/libbamf/bamf-view.c	2012-07-01 18:13:55 +0000
+++ new/lib/libbamf/bamf-view.c	2012-08-10 17:55:58 +0000
@@ -39,6 +39,7 @@
 #include "bamf-factory.h"
 #include "bamf-window.h"
 #include "bamf-marshal.h"
+#include "bamf-tab.h"
 
 #include <dbus/dbus.h>
 #include <dbus/dbus-glib.h>
@@ -67,7 +68,7 @@
   URGENT_CHANGED,
   VISIBLE_CHANGED,
   NAME_CHANGED,
-
+  CHILD_MOVED,
   LAST_SIGNAL,
 };
 
@@ -526,6 +527,17 @@
 }
 
 static void
+bamf_view_child_xid_changed (GObject *object, GParamSpec *pspec, gpointer user_data)
+{
+  BamfView *self;
+  
+  self = (BamfView *)user_data;
+  
+  g_signal_emit (G_OBJECT (self), view_signals[CHILD_MOVED], 0, BAMF_VIEW (object));
+  g_signal_emit (G_OBJECT (self), view_signals[VISIBLE_CHANGED], 0);
+}
+
+static void
 bamf_view_on_child_added (DBusGProxy *proxy, char *path, BamfView *self)
 {
   BamfView *view;
@@ -533,6 +545,10 @@
 
   view = _bamf_factory_view_for_path (_bamf_factory_get_default (), path);
   priv = self->priv;
+  
+  if (BAMF_IS_TAB (view))
+    g_signal_connect (view, "notify::xid", 
+		      G_CALLBACK (bamf_view_child_xid_changed), self);
 
   if (priv->cached_children)
     {
@@ -550,6 +566,9 @@
   BamfViewPrivate *priv;
   view = _bamf_factory_view_for_path (_bamf_factory_get_default (), path);
   priv = self->priv;
+  
+  if (BAMF_IS_TAB (view))
+    g_signal_handlers_disconnect_by_func (view, bamf_view_on_child_added, self);
 
   if (priv->cached_children)
     {
@@ -707,43 +726,43 @@
     return;
 
   dbus_g_proxy_disconnect_signal (priv->proxy,
-                                  "ActiveChanged",
-                                  (GCallback) bamf_view_on_active_changed,
-                                  self);
-
-  dbus_g_proxy_disconnect_signal (priv->proxy,
-                                  "Closed",
-                                  (GCallback) bamf_view_on_closed,
-                                  self);
-
-  dbus_g_proxy_disconnect_signal (priv->proxy,
-                                  "ChildAdded",
-                                  (GCallback) bamf_view_on_child_added,
-                                  self);
-
-  dbus_g_proxy_disconnect_signal (priv->proxy,
-                                  "ChildRemoved",
-                                  (GCallback) bamf_view_on_child_removed,
-                                  self);
-
-  dbus_g_proxy_disconnect_signal (priv->proxy,
-                                  "RunningChanged",
-                                  (GCallback) bamf_view_on_running_changed,
-                                  self);
-
-  dbus_g_proxy_disconnect_signal (priv->proxy,
-                                 "UrgentChanged",
-                                 (GCallback) bamf_view_on_urgent_changed,
-                                 self);
-
-  dbus_g_proxy_disconnect_signal (priv->proxy,
-                                 "UserVisibleChanged",
-                                 (GCallback) bamf_view_on_user_visible_changed,
-                                 self);
-
-  g_signal_handlers_disconnect_by_func (priv->proxy, on_view_proxy_destroyed, self);
-  g_object_unref (priv->proxy);
-  priv->proxy = NULL;
+                                      "ActiveChanged",
+                                      (GCallback) bamf_view_on_active_changed,
+                                      self);
+
+      dbus_g_proxy_disconnect_signal (priv->proxy,
+                                      "Closed",
+                                      (GCallback) bamf_view_on_closed,
+                                      self);
+
+      dbus_g_proxy_disconnect_signal (priv->proxy,
+                                      "ChildAdded",
+                                      (GCallback) bamf_view_on_child_added,
+                                      self);
+
+      dbus_g_proxy_disconnect_signal (priv->proxy,
+                                      "ChildRemoved",
+                                      (GCallback) bamf_view_on_child_removed,
+                                      self);
+
+      dbus_g_proxy_disconnect_signal (priv->proxy,
+                                      "RunningChanged",
+                                      (GCallback) bamf_view_on_running_changed,
+                                      self);
+
+      dbus_g_proxy_disconnect_signal (priv->proxy,
+                                     "UrgentChanged",
+                                     (GCallback) bamf_view_on_urgent_changed,
+                                     self);
+  
+      dbus_g_proxy_disconnect_signal (priv->proxy,
+                                     "UserVisibleChanged",
+                                     (GCallback) bamf_view_on_user_visible_changed,
+                                     self);
+
+      g_signal_handlers_disconnect_by_func (priv->proxy, on_view_proxy_destroyed, self);
+      g_object_unref (priv->proxy);
+      priv->proxy = NULL;
 }
 
 static void
@@ -1038,6 +1057,16 @@
   	              g_cclosure_marshal_VOID__OBJECT,
   	              G_TYPE_NONE, 1, 
   	              BAMF_TYPE_VIEW);
+  
+  view_signals [CHILD_MOVED] = 
+    g_signal_new ("child-moved",
+		  G_OBJECT_CLASS_TYPE (klass),
+		  G_SIGNAL_RUN_FIRST,
+		  0,
+		  NULL, NULL,
+		  g_cclosure_marshal_VOID__OBJECT,
+		  G_TYPE_NONE, 1,
+		  BAMF_TYPE_VIEW);
 
   view_signals [RUNNING_CHANGED] = 
   	g_signal_new ("running-changed",

=== modified file 'src/Makefile.am'
--- old/src/Makefile.am	2012-08-01 14:27:31 +0000
+++ new/src/Makefile.am	2012-08-10 17:55:58 +0000
@@ -53,7 +53,9 @@
 		bamf-application.c \
 		bamf-window.c \
 		bamf-tab.c \
-		bamf-tab-source.c \
+	        bamf-unity-webapps-tab.c \
+		bamf-unity-webapps-observer.c \
+		bamf-unity-webapps-application.c \
 		bamf-indicator-source.c \
 		bamf-indicator.c \
 		bamf-xutils.c \
@@ -74,7 +76,8 @@
 		bamf-window.h \
 		bamf-application.h \
 		bamf-tab.h \
-		bamf-tab-source.h \
+		bamf-unity-webapps-tab.h \
+		bamf-unity-webapps-observer.h \
 		bamf-indicator-source.h \
 		bamf-indicator.h \
 		bamf-xutils.h \
@@ -98,6 +101,7 @@
 		$(GTK_LIBS) \
 		$(WNCK_LIBS) \
 		$(GTOP_LIBS) \
+		$(LIBUNITY_WEBAPPS_LIBS) \
 		$(NULL)
 
 bamfdaemon_CFLAGS = \
@@ -109,6 +113,7 @@
 		$(GTK_CFLAGS) \
 		$(WNCK_CFLAGS) \
 		$(GTOP_CFLAGS) \
+		$(LIBUNITY_WEBAPPS_CFLAGS) \
 		$(NULL)
 
 bamfdaemon_LDFLAGS = \

=== modified file 'src/bamf-application.c'
--- old/src/bamf-application.c	2012-07-28 02:55:58 +0000
+++ new/src/bamf-application.c	2012-08-10 19:08:27 +0000
@@ -24,6 +24,7 @@
 #include "bamf-indicator.h"
 #include "bamf-legacy-window.h"
 #include "bamf-legacy-screen.h"
+#include "bamf-tab.h"
 #include <string.h>
 #include <gio/gdesktopappinfo.h>
 
@@ -45,6 +46,10 @@
   char * wmclass;
   gboolean is_tab_container;
   gboolean show_stubs;
+  gboolean close_when_empty;
+
+  gchar **mimes;
+  gboolean mimes_initialized;
 };
 
 #define STUB_KEY  "X-Ayatana-Appmenu-Show-Stubs"
@@ -57,6 +62,75 @@
   return BAMF_APPLICATION (view)->priv->icon;
 }
 
+void
+bamf_application_emit_dnd_mimes_changed (BamfApplication *application)
+{
+  gchar **mimes = bamf_application_get_dnd_mimes (application);
+
+  if (!mimes)
+    {
+      gchar *empty[] = {NULL};
+
+      mimes = g_strdupv (empty);
+    }
+
+  g_signal_emit_by_name (application->priv->dbus_iface, "dnd-mimes-changed", mimes);
+  application->priv->mimes_initialized = TRUE;
+
+  if (application->priv->mimes)
+    g_strfreev (application->priv->mimes);
+
+  application->priv->mimes = mimes;
+}
+
+static char **
+bamf_application_default_get_dnd_mimes (BamfApplication *application)
+{
+  const char *desktop_file = bamf_application_get_desktop_file (application);
+
+  if (!desktop_file)
+    return NULL;
+
+  GKeyFile* key_file = g_key_file_new ();
+  GError *error = NULL;
+
+  g_key_file_load_from_file (key_file, desktop_file, (GKeyFileFlags) 0, &error);
+  application->priv->mimes_initialized = TRUE;
+
+  if (error)
+    {
+      g_key_file_free(key_file);
+      g_error_free (error);
+      return NULL;
+    }
+
+  char** mimes = g_key_file_get_string_list (key_file, "Desktop Entry", "MimeType", NULL, NULL);
+
+  g_key_file_free (key_file);
+
+  bamf_application_emit_dnd_mimes_changed (application);
+
+  return mimes;
+}
+
+char **
+bamf_application_get_dnd_mimes (BamfApplication *application)
+{
+  g_return_val_if_fail (BAMF_IS_APPLICATION (application), NULL);
+
+  if (application->priv->mimes_initialized)
+    return g_strdupv (application->priv->mimes);
+
+  gchar **mimes = BAMF_APPLICATION_GET_CLASS (application)->get_dnd_mimes (application);
+
+  if (application->priv->mimes)
+    g_strfreev (application->priv->mimes);
+
+  application->priv->mimes = mimes;
+
+  return g_strdupv (mimes);
+}
+
 char *
 bamf_application_get_application_type (BamfApplication *application)
 {
@@ -65,6 +139,17 @@
   return g_strdup (application->priv->app_type);
 }
 
+void
+bamf_application_set_application_type (BamfApplication *application, const gchar *type)
+{
+  g_return_if_fail (BAMF_IS_APPLICATION (application));
+  
+  if (application->priv->app_type)
+    g_free (application->priv->app_type);
+  
+  application->priv->app_type = g_strdup (type);
+}
+
 const char *
 bamf_application_get_desktop_file (BamfApplication *application)
 {
@@ -296,10 +381,12 @@
     {
       view = l->data;
 
-      if (!BAMF_IS_WINDOW (view))
-        continue;
-
-      xid = bamf_window_get_xid (BAMF_WINDOW (view));
+      if (BAMF_IS_WINDOW (view))
+	xid = bamf_window_get_xid (BAMF_WINDOW (view));
+      else if (BAMF_IS_TAB (view))
+	xid = bamf_tab_get_xid (BAMF_TAB (view));
+      else
+	continue;
       g_variant_builder_add (&b, "u", xid);
     }
 
@@ -426,7 +513,7 @@
       if (BAMF_IS_INDICATOR (view))
         visible = TRUE;
 
-      if (!BAMF_IS_WINDOW (view))
+      if (!BAMF_IS_WINDOW (view) && !BAMF_IS_TAB (view))
         continue;
 
       if (bamf_view_is_urgent (view))
@@ -441,8 +528,10 @@
     }
 
   bamf_view_set_urgent       (BAMF_VIEW (self), urgent);
-  bamf_view_set_user_visible (BAMF_VIEW (self), visible);
-  bamf_view_set_running      (BAMF_VIEW (self), running);
+  if (!((self->priv->close_when_empty == FALSE) && running == FALSE))
+    bamf_view_set_user_visible (BAMF_VIEW (self), visible);
+  if ((running == TRUE) || self->priv->close_when_empty)
+    bamf_view_set_running      (BAMF_VIEW (self), running);
   bamf_view_set_active       (BAMF_VIEW (self), active);
 }
 
@@ -465,6 +554,15 @@
 }
 
 static void
+view_xid_changed (GObject *object, GParamSpec *pspec, gpointer user_data)
+{
+  BamfApplication *self;
+  
+  self = (BamfApplication *)user_data;
+  bamf_application_ensure_flags (self);
+}
+
+static void
 view_exported (BamfView *view, BamfApplication *self)
 {
   g_signal_emit_by_name (self, "window-added", bamf_view_get_path (view));
@@ -493,6 +591,12 @@
   g_signal_connect (G_OBJECT (child), "user-visible-changed",
                     (GCallback) view_visible_changed, view);
 
+  if (BAMF_IS_TAB (child))
+    {
+      g_signal_connect (G_OBJECT (child), "notify::xid",
+			(GCallback) view_xid_changed, view);
+    }
+
   bamf_application_ensure_flags (BAMF_APPLICATION (view));
 
   bamf_application_setup_icon_and_name (application);
@@ -566,6 +670,7 @@
 static void
 bamf_application_child_removed (BamfView *view, BamfView *child)
 {
+  BamfApplication *self = BAMF_APPLICATION (view);
   if (BAMF_IS_WINDOW (child))
     {
       if (bamf_view_is_on_bus (child))
@@ -577,9 +682,9 @@
   g_signal_handlers_disconnect_by_func (G_OBJECT (child), view_urgent_changed, view);
   g_signal_handlers_disconnect_by_func (G_OBJECT (child), view_visible_changed, view);
 
-  bamf_application_ensure_flags (BAMF_APPLICATION (view));
+  bamf_application_ensure_flags (self);
 
-  if (bamf_view_get_children (view) == NULL)
+  if ((bamf_view_get_children (view) == NULL)  && (self->priv->close_when_empty))
     {
       bamf_view_close (view);
     }
@@ -639,6 +744,36 @@
 }
 
 static gboolean
+on_dbus_handle_focus_child (BamfDBusItemApplication *interface,
+			   GDBusMethodInvocation *invocation,
+			   BamfApplication *self)
+{
+  GVariant *out_variant;
+  BamfView *focus_child;
+  
+  out_variant = NULL;
+  
+  focus_child = bamf_application_get_focus_child (self);
+  
+  if (focus_child == NULL)
+    {
+      out_variant = g_variant_new("(s)", "");
+    }
+  else
+    {
+      const gchar *path;
+      
+      path = bamf_view_get_path (BAMF_VIEW (focus_child));
+      
+      out_variant = g_variant_new("(s)", path);
+    }
+
+  g_dbus_method_invocation_return_value (invocation, out_variant);
+
+  return TRUE;
+}
+
+static gboolean
 on_dbus_handle_desktop_file (BamfDBusItemApplication *interface,
                              GDBusMethodInvocation *invocation,
                              BamfApplication *self)
@@ -651,6 +786,53 @@
 }
 
 static gboolean
+on_dbus_handle_dnd_mimes (BamfDBusItemApplication *interface,
+                          GDBusMethodInvocation *invocation,
+                          BamfApplication *self)
+{
+  gchar **mimes = bamf_application_get_dnd_mimes (self);
+
+  GVariantBuilder *builder;
+  GVariant *value;
+  gchar **it;
+
+  builder = g_variant_builder_new (G_VARIANT_TYPE ("as"));
+  if (mimes)
+    for (it = mimes; *it; it++)
+      {
+        g_variant_builder_add (builder, "s", *it);
+      }
+  value = g_variant_new ("(as)", builder);
+
+  g_dbus_method_invocation_return_value (invocation,
+                                         value);
+
+  g_variant_builder_unref (builder);
+
+  g_strfreev (mimes);
+
+  return TRUE;
+}
+
+static gboolean
+on_dbus_handle_application_menu (BamfDBusItemApplication *interface,
+				 GDBusMethodInvocation *invocation,
+				 BamfApplication *self)
+{
+  gchar *name, *path;
+  
+  bamf_application_get_application_menu (self, &name, &path);
+  
+  name = name ? name : "";
+  path = path ? path : "";
+  
+  g_dbus_method_invocation_return_value (invocation,
+					 g_variant_new ("(ss)", name, path));
+  
+  return TRUE;
+}
+
+static gboolean
 on_dbus_handle_application_type (BamfDBusItemApplication *interface,
                                  GDBusMethodInvocation *invocation,
                                  BamfApplication *self)
@@ -701,6 +883,9 @@
       priv->wmclass = NULL;
     }
 
+  g_strfreev (priv->mimes);
+  priv->mimes = NULL;
+
   g_signal_handlers_disconnect_by_func (G_OBJECT (bamf_matcher_get_default ()),
                                         matcher_favorites_changed, object);
 
@@ -728,6 +913,8 @@
   priv->app_type = g_strdup ("system");
   priv->show_stubs = TRUE;
   priv->wmclass = NULL;
+  
+  priv->close_when_empty = TRUE;
 
   /* Initializing the dbus interface */
   priv->dbus_iface = bamf_dbus_item_application_skeleton_new ();
@@ -744,9 +931,18 @@
   g_signal_connect (priv->dbus_iface, "handle-xids",
                     G_CALLBACK (on_dbus_handle_xids), self);
 
+  g_signal_connect (priv->dbus_iface, "handle-focus-child",
+                    G_CALLBACK (on_dbus_handle_focus_child), self);
+
   g_signal_connect (priv->dbus_iface, "handle-desktop-file",
                     G_CALLBACK (on_dbus_handle_desktop_file), self);
 
+  g_signal_connect (priv->dbus_iface, "handle-dnd-mimes",
+                    G_CALLBACK (on_dbus_handle_dnd_mimes), self);
+
+  g_signal_connect (priv->dbus_iface, "handle-application-menu",
+		    G_CALLBACK (on_dbus_handle_application_menu), self);
+
   g_signal_connect (priv->dbus_iface, "handle-application-type",
                     G_CALLBACK (on_dbus_handle_application_type), self);
 
@@ -778,6 +974,8 @@
   view_class->get_icon = bamf_application_get_icon;
   view_class->stable_bus_name = bamf_application_get_stable_bus_name;
 
+  klass->get_dnd_mimes = bamf_application_default_get_dnd_mimes;
+
   g_type_class_add_private (klass, sizeof (BamfApplicationPrivate));
 }
 
@@ -840,3 +1038,47 @@
     g_return_val_if_fail(BAMF_IS_APPLICATION(application), TRUE);
     return application->priv->show_stubs;
 }
+
+
+gboolean
+bamf_application_get_close_when_empty (BamfApplication *application)
+{
+  g_return_val_if_fail (BAMF_IS_APPLICATION(application), FALSE);
+  return application->priv->close_when_empty;
+}
+
+void
+bamf_application_set_close_when_empty (BamfApplication *application, gboolean close)
+{
+  g_return_if_fail (BAMF_IS_APPLICATION(application));
+  application->priv->close_when_empty = close;
+}
+
+void
+bamf_application_get_application_menu (BamfApplication *application, gchar **name, gchar **object_path)
+{
+  g_return_if_fail (BAMF_IS_APPLICATION (application));
+  
+  if (BAMF_APPLICATION_GET_CLASS (application)->get_application_menu)
+    {
+      BAMF_APPLICATION_GET_CLASS (application)->get_application_menu (application, name, object_path);
+    }
+  else
+    {
+      *name = NULL;
+      *object_path = NULL;
+    }
+}
+
+BamfView *
+bamf_application_get_focus_child (BamfApplication *application)
+{
+  g_return_val_if_fail (BAMF_IS_APPLICATION (application), NULL);
+  
+  if (BAMF_APPLICATION_GET_CLASS (application)->get_focus_child)
+    {
+      return BAMF_APPLICATION_GET_CLASS (application)->get_focus_child (application);
+    }
+  
+  return NULL;
+}

=== modified file 'src/bamf-application.h'
--- old/src/bamf-application.h	2012-01-12 16:30:44 +0000
+++ new/src/bamf-application.h	2012-08-10 17:56:01 +0000
@@ -41,6 +41,11 @@
 struct _BamfApplicationClass
 {
   BamfViewClass parent;
+  
+  void (*get_application_menu) (BamfApplication *application, gchar **name, gchar **path);
+  BamfView* (*get_focus_child) (BamfApplication *application);
+  char ** (*get_dnd_mimes) (BamfApplication *application);
+
 };
 
 struct _BamfApplication
@@ -53,10 +58,14 @@
 
 GType             bamf_application_get_type                   (void) G_GNUC_CONST;
 
+void              bamf_application_emit_dnd_mimes_changed     (BamfApplication *application);
+
 const char      * bamf_application_get_desktop_file           (BamfApplication *application);
 void              bamf_application_set_desktop_file           (BamfApplication *application,
                                                                const char * desktop_file);
 
+char           ** bamf_application_get_dnd_mimes              (BamfApplication *application);
+
 GVariant        * bamf_application_get_xids                   (BamfApplication *application);
 
 gboolean          bamf_application_manages_xid                (BamfApplication *application,
@@ -78,4 +87,15 @@
 
 BamfApplication * bamf_application_new_with_wmclass           (const char *wmclass);
 
+gboolean bamf_application_get_close_when_empty (BamfApplication *application);
+
+void bamf_application_set_close_when_empty (BamfApplication *application, gboolean close);
+
+void bamf_application_set_application_type (BamfApplication *application, const gchar *type);
+
+void bamf_application_get_application_menu (BamfApplication *application, gchar **name, gchar **object_path);
+
+BamfView        * bamf_application_get_focus_child             (BamfApplication *application);
+
+
 #endif

=== modified file 'src/bamf-control.c'
--- old/src/bamf-control.c	2011-12-22 21:04:56 +0000
+++ new/src/bamf-control.c	2012-08-10 17:56:01 +0000
@@ -19,11 +19,11 @@
  */
 
 
-#include "bamf-tab-source.h"
 #include "bamf-matcher.h"
 #include "bamf-control.h"
 #include "bamf-indicator-source.h"
 #include "bamf-daemon.h"
+#include "bamf-unity-webapps-observer.h"
 
 G_DEFINE_TYPE (BamfControl, bamf_control, BAMF_DBUS_TYPE_CONTROL_SKELETON);
 #define BAMF_CONTROL_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE(obj, \
@@ -110,19 +110,6 @@
 }
 
 static gboolean
-on_dbus_handle_register_tab_provider (BamfDBusControl *interface,
-                                      GDBusMethodInvocation *invocation,
-                                      const gchar *tab_path,
-                                      BamfControl *self)
-{
-  const gchar *sender = g_dbus_method_invocation_get_sender (invocation);
-  bamf_control_register_tab_provider (self, sender, tab_path);
-  g_dbus_method_invocation_return_value (invocation, NULL);
-
-  return TRUE;
-}
-
-static gboolean
 on_dbus_handle_register_application_for_pid (BamfDBusControl *interface,
                                              GDBusMethodInvocation *invocation,
                                              const gchar *application,
@@ -151,11 +138,10 @@
   g_signal_connect (self, "handle-om-nom-nom-desktop-file",
                     G_CALLBACK (on_dbus_handle_om_nom_nom_desktop_file), self);
 
-  g_signal_connect (self, "handle-register-tab-provider",
-                    G_CALLBACK (on_dbus_handle_register_tab_provider), self);
-
   g_signal_connect (self, "handle-register-application-for-pid",
                     G_CALLBACK (on_dbus_handle_register_application_for_pid), self);
+  
+  bamf_unity_webapps_observer_new ();
 }
 
 static void
@@ -202,26 +188,6 @@
   bamf_matcher_load_desktop_file (matcher, path);
 }
 
-void
-bamf_control_register_tab_provider (BamfControl *control,
-                                    const char *sender,
-                                    const char *path)
-{
-  BamfTabSource *source;
-
-  if (!path || !sender)
-    {
-      return;
-    }
-
-  source = bamf_tab_source_new (g_strdup (sender), g_strdup (path));
-
-  if (BAMF_IS_TAB_SOURCE (source))
-    {
-      control->priv->sources = g_list_prepend (control->priv->sources, source);
-    }
-}
-
 static gboolean
 bamf_control_on_quit (BamfControl *control)
 {

=== modified file 'src/bamf-matcher.c'
--- old/src/bamf-matcher.c	2012-07-28 14:21:01 +0000
+++ new/src/bamf-matcher.c	2012-08-10 17:56:37 +0000
@@ -254,7 +254,7 @@
   bamf_matcher_unregister_view (self, view);
 }
 
-static void
+void
 bamf_matcher_register_view_stealing_ref (BamfMatcher *self, BamfView *view)
 {
   const char *path, *type;
@@ -2178,7 +2178,8 @@
     }
 
   /* we have a window who is ready to be matched */
-  handle_raw_window (self, window);
+  if (bamf_legacy_window_get_window_type (window) != BAMF_WINDOW_DOCK)
+    handle_raw_window (self, window);
 }
 
 static void

=== modified file 'src/bamf-matcher.h'
--- old/src/bamf-matcher.h	2012-04-29 17:32:12 +0000
+++ new/src/bamf-matcher.h	2012-08-10 17:56:37 +0000
@@ -23,6 +23,7 @@
 #define __BAMFMATCHER_H__
 
 #include "bamf.h"
+#include "bamf-view.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -109,6 +110,8 @@
 GVariant    * bamf_matcher_get_window_stack_for_monitor  (BamfMatcher *matcher,
                                                           gint monitor);
 
+void bamf_matcher_register_view_stealing_ref (BamfMatcher *self, BamfView *view);
+
 BamfMatcher * bamf_matcher_get_default                   (void);
 
 #endif

=== removed file 'src/bamf-tab-source.c'
--- old/src/bamf-tab-source.c	2011-12-22 00:33:12 +0000
+++ new/src/bamf-tab-source.c	1970-01-01 00:00:00 +0000
@@ -1,456 +0,0 @@
-/*
- * Copyright (C) 2010-2011 Canonical Ltd
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 3 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Authored by: Jason Smith <jason.smith@canonical.com>
- *              Marco Trevisan (Treviño) <3v1n0@ubuntu.com>
- *
- */
-
-#include "bamf-view.h"
-#include "bamf-tab-source.h"
-#include "bamf-tab.h"
-#include "bamf-marshal.h"
-#include "bamf-gdbus-browser-generated.h"
-
-G_DEFINE_TYPE (BamfTabSource, bamf_tab_source, G_TYPE_OBJECT);
-#define BAMF_TAB_SOURCE_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE(obj, \
-BAMF_TYPE_TAB_SOURCE, BamfTabSourcePrivate))
-
-enum
-{
-  PROP_0,
-
-  PROP_BUS,
-  PROP_PATH,
-};
-
-enum
-{
-  REMOTE_TAB_URI_CHANGED,
-  REMOTE_TAB_OPENED,
-  REMOTE_TAB_CLOSED,
-  TAB_OPENED,
-  TAB_CLOSED,
-
-  LAST_SIGNAL,
-};
-
-static guint bamf_tab_source_signals[LAST_SIGNAL] = { 0 };
-
-struct _BamfTabSourcePrivate
-{
-  BamfDBusBrowser *proxy;
-  char       *bus;
-  char       *path;
-  GHashTable *tabs;
-};
-
-char **
-bamf_tab_source_tab_ids (BamfTabSource *self)
-{
-  BamfTabSourcePrivate *priv;
-  GError *error = NULL;
-  char **ids = NULL;
-
-  g_return_val_if_fail (BAMF_IS_TAB_SOURCE (self), NULL);
-  priv = self->priv;
-
-  if (!bamf_dbus_browser__call_tab_ids_sync (priv->proxy, &ids, NULL, &error))
-    {
-      g_warning ("Failed to get tab ids: %s", error->message);
-      g_error_free (error);
-      return NULL;
-    }
-
-  return ids;
-}
-
-void
-bamf_tab_source_show_tab (BamfTabSource *self, char *id)
-{
-  BamfTabSourcePrivate *priv;
-  GError *error = NULL;
-
-  g_return_if_fail (BAMF_IS_TAB_SOURCE (self));
-  priv = self->priv;
-
-  if (!bamf_dbus_browser__call_show_tab_sync (priv->proxy, id, NULL, &error))
-    {
-      g_warning ("Failed to show tab: %s", error->message);
-      g_error_free (error);
-    }
-}
-
-gchar *
-bamf_tab_source_get_tab_preview (BamfTabSource *self,
-                                 char *id)
-{
-  BamfTabSourcePrivate *priv;
-  GError *error = NULL;
-  gchar *preview_data = NULL;
-
-  g_return_val_if_fail (BAMF_IS_TAB_SOURCE (self), NULL);
-  priv = self->priv;
-
-  if (!bamf_dbus_browser__call_tab_preview_sync (priv->proxy, id, &preview_data,
-                                                 NULL, &error))
-    {
-      g_warning ("Failed to get tab preview data: %s", error->message);
-      g_error_free (error);
-      return NULL;
-    }
-
-  return preview_data;
-}
-
-char *
-bamf_tab_source_get_tab_uri (BamfTabSource *self,
-                             char *id)
-{
-  BamfTabSourcePrivate *priv;
-  GError *error = NULL;
-  char *uri = NULL;
-
-  g_return_val_if_fail (BAMF_IS_TAB_SOURCE (self), NULL);
-  priv = self->priv;
-
-  if (!bamf_dbus_browser__call_tab_uri_sync (priv->proxy, id, &uri, NULL, &error))
-    {
-      g_warning ("Failed to get tab URI: %s", error->message);
-      g_error_free (error);
-      return NULL;
-    }
-
-  return uri;
-}
-
-guint32
-bamf_tab_source_get_tab_xid (BamfTabSource *self,
-                             char *id)
-{
-  BamfTabSourcePrivate *priv;
-  GError *error = NULL;
-  guint32 xid = 0;
-
-  g_return_val_if_fail (BAMF_IS_TAB_SOURCE (self), 0);
-  priv = self->priv;
-
-  if (!bamf_dbus_browser__call_tab_xid_sync (priv->proxy, id, &xid, NULL, &error))
-    {
-      g_warning ("Failed to get tab XID: %s", error->message);
-      g_error_free (error);
-      return 0;
-    }
-
-  return xid;
-}
-
-static void
-bamf_tab_source_on_tab_opened (BamfDBusBrowser *proxy, const char *id,
-                               BamfTabSource *source)
-{
-  BamfTab *tab;
-
-  g_return_if_fail (BAMF_IS_TAB_SOURCE (source));
-
-  g_signal_emit (source, REMOTE_TAB_OPENED, 0, id);
-
-  tab = bamf_tab_new (source, id);
-  g_hash_table_insert (source->priv->tabs, g_strdup (id), tab);
-
-  g_signal_emit (source, TAB_OPENED, 0, tab);
-}
-
-static void
-bamf_tab_source_on_tab_closed (BamfDBusBrowser *proxy, const char *id,
-                               BamfTabSource *source)
-{
-  BamfTab *tab;
-
-  g_return_if_fail (BAMF_IS_TAB_SOURCE (source));
-
-  g_signal_emit (source, REMOTE_TAB_CLOSED, 0, id);
-
-  tab = g_hash_table_lookup (source->priv->tabs, id);
-
-  if (!BAMF_IS_TAB (tab))
-    return;
-
-  g_hash_table_remove (source->priv->tabs, id);
-
-  g_signal_emit (source, TAB_CLOSED, 0, tab);
-  g_object_unref (tab);
-}
-
-static void
-bamf_tab_source_on_uri_changed (BamfDBusBrowser *proxy, const char *id,
-                                const char *old_uri, char *new_uri, BamfTabSource *source)
-{
-  g_signal_emit (source, REMOTE_TAB_URI_CHANGED, 0, id, old_uri, new_uri);
-}
-
-static void
-bamf_tab_source_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec)
-{
-  BamfTabSource *self;
-
-  self = BAMF_TAB_SOURCE (object);
-
-  switch (property_id)
-    {
-      case PROP_PATH:
-        self->priv->path = g_strdup (g_value_get_string (value));
-        break;
-      case PROP_BUS:
-        self->priv->bus = g_strdup (g_value_get_string (value));
-        break;
-      default:
-        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
-    }
-}
-
-static void
-bamf_tab_source_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec)
-{
-  BamfTabSource *self;
-
-  self = BAMF_TAB_SOURCE (object);
-
-  switch (property_id)
-    {
-      case PROP_PATH:
-        g_value_set_string (value, self->priv->path);
-        break;
-      case PROP_BUS:
-        g_value_set_string (value, self->priv->path);
-        break;
-      default:
-        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
-    }
-}
-
-static void bamf_tab_source_reconnect (GObject *object, GParamSpec *pspec, BamfTabSource *self);
-
-static void
-on_proxy_ready_cb (GDBusProxy *proxy, GAsyncResult *res, BamfTabSource *self)
-{
-  BamfDBusBrowser *bproxy;
-  GError *error = NULL;
-  g_return_if_fail (BAMF_IS_TAB_SOURCE (self));
-
-  bproxy = bamf_dbus_browser__proxy_new_for_bus_finish (res, &error);
-
-  if (error)
-    {
-      g_critical ("Unable to get org.ayatana.bamf.browser object from bus %s: %s",
-                  self->priv->bus, error->message);
-      g_error_free (error);
-    }
-  else
-    {
-      gchar *owner = g_dbus_proxy_get_name_owner (G_DBUS_PROXY (bproxy));
-
-      if (owner)
-        {
-          g_free (owner);
-
-          if (self->priv->proxy)
-            g_object_unref (self->priv->proxy);
-
-          self->priv->proxy = bproxy;
-
-          g_signal_connect (self->priv->proxy, "tab-uri-changed",
-                            (GCallback) bamf_tab_source_on_uri_changed, self);
-
-          g_signal_connect (self->priv->proxy, "tab-opened",
-                            (GCallback) bamf_tab_source_on_tab_opened, self);
-
-          g_signal_connect (self->priv->proxy, "tab-closed",
-                            (GCallback) bamf_tab_source_on_tab_closed, self);
-
-          g_signal_connect (self->priv->proxy, "notify::g-name-owner",
-                            G_CALLBACK (bamf_tab_source_reconnect), self);
-
-        }
-      else
-        {
-           g_debug ("Failed to get notification approver proxy: no owner available");
-           g_object_unref (proxy);
-        }
-    }
-}
-
-static void
-bamf_tab_source_reconnect (GObject *object, GParamSpec *pspec, BamfTabSource *self)
-{
-  g_return_if_fail (BAMF_IS_TAB_SOURCE (self));
-
-  if (self->priv->proxy)
-    {
-      g_object_unref (self->priv->proxy);
-      self->priv->proxy = NULL;
-    }
-
-  bamf_dbus_browser__proxy_new_for_bus (G_BUS_TYPE_SESSION,
-                                        G_DBUS_PROXY_FLAGS_NONE,
-                                        self->priv->bus,
-                                        self->priv->path,
-                                        NULL,
-                                        (GAsyncReadyCallback) on_proxy_ready_cb,
-                                        self);
-}
-
-static void
-bamf_tab_source_constructed (GObject *object)
-{
-  BamfTabSource *source;
-  BamfTabSourcePrivate *priv;
-
-  if (G_OBJECT_CLASS (bamf_tab_source_parent_class)->constructed)
-    G_OBJECT_CLASS (bamf_tab_source_parent_class)->constructed (object);
-
-  source = BAMF_TAB_SOURCE (object);
-  priv = source->priv;
-
-  bamf_dbus_browser__proxy_new_for_bus (G_BUS_TYPE_SESSION,
-                                        G_DBUS_PROXY_FLAGS_NONE,
-                                        priv->bus,
-                                        priv->path,
-                                        NULL,
-                                        (GAsyncReadyCallback) on_proxy_ready_cb,
-                                        source);
-}
-
-static void
-bamf_tab_source_dispose (GObject *object)
-{
-  BamfTabSource *self;
-
-  self = BAMF_TAB_SOURCE (object);
-
-  if (self->priv->bus)
-    {
-      g_free (self->priv->bus);
-      self->priv->bus = NULL;
-    }
-
-  if (self->priv->path)
-    {
-      g_free (self->priv->path);
-      self->priv->path = NULL;
-    }
-
-  if (self->priv->proxy)
-    {
-      g_object_unref (self->priv->proxy);
-      self->priv->proxy = NULL;
-    }
-
-  G_OBJECT_CLASS (bamf_tab_source_parent_class)->dispose (object);
-}
-
-static void
-bamf_tab_source_init (BamfTabSource * self)
-{
-  BamfTabSourcePrivate *priv;
-  priv = self->priv = BAMF_TAB_SOURCE_GET_PRIVATE (self);
-
-  priv->tabs = g_hash_table_new_full ((GHashFunc) g_str_hash,
-                                      (GEqualFunc) g_str_equal,
-                                      (GDestroyNotify) g_free,
-                                      NULL);
-}
-
-static void
-bamf_tab_source_class_init (BamfTabSourceClass * klass)
-{
-  GParamSpec *pspec;
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->dispose      = bamf_tab_source_dispose;
-  object_class->set_property = bamf_tab_source_set_property;
-  object_class->get_property = bamf_tab_source_get_property;
-  object_class->constructed  = bamf_tab_source_constructed;
-
-  g_type_class_add_private (klass, sizeof (BamfTabSourcePrivate));
-
-  pspec = g_param_spec_string ("path", "path", "path", NULL, G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
-  g_object_class_install_property (object_class, PROP_PATH, pspec);
-
-  pspec = g_param_spec_string ("bus", "bus", "bus", NULL, G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
-  g_object_class_install_property (object_class, PROP_BUS, pspec);
-
-  bamf_tab_source_signals [REMOTE_TAB_URI_CHANGED] =
-    g_signal_new ("remote-tab-uri-changed",
-                  G_OBJECT_CLASS_TYPE (klass),
-                  G_SIGNAL_RUN_FIRST,
-                  0,
-                  NULL, NULL,
-                  bamf_marshal_VOID__STRING_STRING_STRING,
-                  G_TYPE_NONE, 3,
-                  G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
-
-  bamf_tab_source_signals [REMOTE_TAB_OPENED] =
-    g_signal_new ("remote-tab-opened",
-                  G_OBJECT_CLASS_TYPE (klass),
-                  G_SIGNAL_RUN_FIRST,
-                  0,
-                  NULL, NULL,
-                  g_cclosure_marshal_VOID__STRING,
-                  G_TYPE_NONE, 1,
-                  G_TYPE_STRING);
-
-  bamf_tab_source_signals [REMOTE_TAB_CLOSED] =
-    g_signal_new ("remote-tab-closed",
-                  G_OBJECT_CLASS_TYPE (klass),
-                  G_SIGNAL_RUN_FIRST,
-                  0,
-                  NULL, NULL,
-                  g_cclosure_marshal_VOID__STRING,
-                  G_TYPE_NONE, 1,
-                  G_TYPE_STRING);
-
-  bamf_tab_source_signals [TAB_OPENED] =
-    g_signal_new ("tab-opened",
-                  G_OBJECT_CLASS_TYPE (klass),
-                  G_SIGNAL_RUN_FIRST,
-                  0,
-                  NULL, NULL,
-                  g_cclosure_marshal_VOID__OBJECT,
-                  G_TYPE_NONE, 1,
-                  BAMF_TYPE_TAB);
-
-  bamf_tab_source_signals [TAB_CLOSED] =
-    g_signal_new ("tab-closed",
-                  G_OBJECT_CLASS_TYPE (klass),
-                  G_SIGNAL_RUN_FIRST,
-                  0,
-                  NULL, NULL,
-                  g_cclosure_marshal_VOID__OBJECT,
-                  G_TYPE_NONE, 1,
-                  BAMF_TYPE_TAB);
-}
-
-BamfTabSource *
-bamf_tab_source_new (char *bus, char *path)
-{
-  BamfTabSource *self;
-  self = (BamfTabSource *) g_object_new (BAMF_TYPE_TAB_SOURCE,
-                                         "path", path,
-                                         "bus", bus,
-                                         NULL);
-
-  return self;
-}

=== removed file 'src/bamf-tab-source.h'
--- old/src/bamf-tab-source.h	2011-12-22 00:33:12 +0000
+++ new/src/bamf-tab-source.h	1970-01-01 00:00:00 +0000
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2010-2011 Canonical Ltd
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 3 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Authored by: Jason Smith <jason.smith@canonical.com>
- *              Marco Trevisan (Treviño) <3v1n0@ubuntu.com>
- *
- */
-
-#ifndef __BAMFTABSOURCE_H__
-#define __BAMFTABSOURCE_H__
-
-#include "bamf.h"
-#include <glib.h>
-#include <glib-object.h>
-
-#define BAMF_TYPE_TAB_SOURCE			(bamf_tab_source_get_type ())
-#define BAMF_TAB_SOURCE(obj)			(G_TYPE_CHECK_INSTANCE_CAST ((obj), BAMF_TYPE_TAB_SOURCE, BamfTabSource))
-#define BAMF_IS_TAB_SOURCE(obj)			(G_TYPE_CHECK_INSTANCE_TYPE ((obj), BAMF_TYPE_TAB_SOURCE))
-#define BAMF_TAB_SOURCE_CLASS(klass)		(G_TYPE_CHECK_CLASS_CAST ((klass), BAMF_TYPE_TAB_SOURCE, BamfTabSourceClass))
-#define BAMF_IS_TAB_SOURCE_CLASS(klass)		(G_TYPE_CHECK_CLASS_TYPE ((klass), BAMF_TYPE_TAB_SOURCE))
-#define BAMF_TAB_SOURCE_GET_CLASS(obj)		(G_TYPE_INSTANCE_GET_CLASS ((obj), BAMF_TYPE_TAB_SOURCE, BamfTabSourceClass))
-
-typedef struct _BamfTabSource BamfTabSource;
-typedef struct _BamfTabSourceClass BamfTabSourceClass;
-typedef struct _BamfTabSourcePrivate BamfTabSourcePrivate;
-
-struct _BamfTabSourceClass
-{
-  GObjectClass parent;
-
-  /*< signals >*/
-  void    (*tab_uri_changed)   (char *id, char *old_uri, char *new_uri);
-  void    (*tab_opened)        (char *id);
-  void    (*tab_closed)        (char *id);
-};
-
-struct _BamfTabSource
-{
-  GObject parent;
-
-  /* private */
-  BamfTabSourcePrivate *priv;
-};
-
-GType           bamf_tab_source_get_type         (void) G_GNUC_CONST;
-
-char         ** bamf_tab_source_tab_ids          (BamfTabSource *self);
-
-void            bamf_tab_source_show_tab         (BamfTabSource *self, char *id);
-
-gchar         * bamf_tab_source_get_tab_preview  (BamfTabSource *self, char *id);
-
-char          * bamf_tab_source_get_tab_uri      (BamfTabSource *self, char *id);
-
-guint32         bamf_tab_source_get_tab_xid      (BamfTabSource *self, char *id);
-
-BamfTabSource * bamf_tab_source_new              (char *bus, char *path);
-
-#endif

=== modified file 'src/bamf-tab.c'
--- old/src/bamf-tab.c	2011-12-23 01:36:16 +0000
+++ new/src/bamf-tab.c	2012-08-10 17:56:37 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011 Canonical Ltd
+ * Copyright (C) 2012 Canonical Ltd
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 3 as
@@ -13,224 +13,119 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
- * Authored by: Jason Smith <jason.smith@canonical.com>
- *              Marco Trevisan (Treviño) <3v1n0@ubuntu.com>
+ * Authored by: 
+ *              Robert Carr <racarr@canonical.com>
  *
  */
 
 #include "bamf-tab.h"
-#include "bamf-tab-source.h"
+#include "bamf-gdbus-view-generated.h"
 
 #define BAMF_TAB_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE(obj, \
 BAMF_TYPE_TAB, BamfTabPrivate))
 
 static void bamf_tab_dbus_iface_init (BamfDBusItemTabIface *iface);
-G_DEFINE_TYPE_WITH_CODE (BamfTab, bamf_tab, BAMF_TYPE_VIEW,
-                         G_IMPLEMENT_INTERFACE (BAMF_DBUS_ITEM_TYPE_TAB,
-                                                bamf_tab_dbus_iface_init));
+G_DEFINE_ABSTRACT_TYPE_WITH_CODE (BamfTab, bamf_tab, BAMF_TYPE_VIEW,
+				  G_IMPLEMENT_INTERFACE (BAMF_DBUS_ITEM_TYPE_TAB,
+							 bamf_tab_dbus_iface_init));
 
 enum
 {
   PROP_0,
-
-  PROP_ID,
-  PROP_SOURCE,
+  PROP_LOCATION,
+  PROP_XID,
+  PROP_DESKTOP_ID,
+  PROP_IS_FOREGROUND_TAB
 };
 
 struct _BamfTabPrivate
 {
   BamfDBusItemTab *dbus_iface;
-  char *id;
-  char *uri;
-  BamfTabSource *source;
+
+  char *location;
+  gchar *desktop_id;
+
+  guint64 xid;
+  gboolean is_foreground;
 };
 
-char *
-bamf_tab_current_uri (BamfTab *self)
-{
-  g_return_val_if_fail (BAMF_IS_TAB (self), NULL);
-
-  return g_strdup (self->priv->uri);
-}
-
-void
-bamf_tab_show (BamfTab *tab)
-{
-  g_return_if_fail (BAMF_IS_TAB (tab));
-
-  bamf_tab_source_show_tab (tab->priv->source, tab->priv->id);
-}
-
-guint32 bamf_tab_parent_xid (BamfTab *tab)
-{
-  g_return_val_if_fail (BAMF_IS_TAB (tab), 0);
-
-  return bamf_tab_source_get_tab_xid (tab->priv->source, tab->priv->id);
-}
-
-gchar *
-bamf_tab_get_preview (BamfTab *tab)
-{
-  return bamf_tab_source_get_tab_preview (tab->priv->source, tab->priv->id);
-}
-
-static const char *
+static const gchar *
 bamf_tab_get_view_type (BamfView *view)
 {
   return "tab";
 }
 
 static void
-on_tab_source_uri_changed (BamfTabSource *source, char *id,
-                           char *old_uri, char *new_uri, BamfTab *self)
-{
-  if (g_strcmp0 (id, self->priv->id) != 0)
-    return;
-
-  g_free (self->priv->uri);
-  self->priv->uri = g_strdup (new_uri);
-
-  g_signal_emit_by_name (self, "uri-changed", old_uri, new_uri);
-}
-
-static void
-on_uri_changed (BamfTab *self, const gchar *old_uri, const gchar *new_uri, gpointer _not_used)
-{
-  g_return_if_fail (BAMF_IS_TAB (self));
-  g_signal_emit_by_name (self->priv->dbus_iface, "uri-changed", old_uri, new_uri);
-}
-
-static gboolean
-on_dbus_handle_show_tab (BamfDBusItemTab *interface,
-                         GDBusMethodInvocation *invocation,
-                         BamfTab *self)
-{
-  bamf_tab_show (self);
-  g_dbus_method_invocation_return_value (invocation, NULL);
-
-  return TRUE;
-}
-
-static gboolean
-on_dbus_handle_parent_xid (BamfDBusItemTab *interface,
-                           GDBusMethodInvocation *invocation,
-                           BamfTab *self)
-{
-  guint32 parent_xid = bamf_tab_parent_xid (self);
-  g_dbus_method_invocation_return_value (invocation,
-                                         g_variant_new ("(u)", parent_xid));
-
-  return TRUE;
-}
-
-static gboolean
-on_dbus_handle_current_uri (BamfDBusItemTab *interface,
-                            GDBusMethodInvocation *invocation,
-                            BamfTab *self)
-{
-  char *current_uri = self->priv->uri ? self->priv->uri : "";
-  g_dbus_method_invocation_return_value (invocation,
-                                         g_variant_new ("(s)", current_uri));
-
-  return TRUE;
-}
-
-static gboolean
-on_dbus_handle_preview (BamfDBusItemTab *interface,
-                        GDBusMethodInvocation *invocation,
-                        BamfTab *self)
-{
-  gchar *preview = bamf_tab_get_preview (self);
-
-  if (preview)
-    {
-      bamf_dbus_item_tab_complete_preview (interface, invocation, preview);
-      g_free (preview);
-    }
-  else
-    {
-      g_dbus_method_invocation_return_value (invocation,
-                                             g_variant_new ("(ay)", NULL));
-    }
-
-  return TRUE;
+bamf_tab_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec)
+{
+  BamfTab *self;
+  
+  self = BAMF_TAB (object);
+  
+  switch (property_id)
+    {
+    case PROP_LOCATION:
+      g_value_set_string (value, self->priv->location);
+      break;
+    case PROP_XID:
+      g_value_set_uint64  (value, self->priv->xid);
+      break;
+    case PROP_DESKTOP_ID:
+      g_value_set_string (value, self->priv->desktop_id);
+      break;
+    case PROP_IS_FOREGROUND_TAB:
+      g_value_set_boolean (value, self->priv->is_foreground);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    }
 }
 
 static void
 bamf_tab_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec)
 {
   BamfTab *self;
-
-  self = BAMF_TAB (object);
-
-  switch (property_id)
-    {
-      case PROP_ID:
-        self->priv->id = g_value_dup_string (value);
-        break;
-
-      case PROP_SOURCE:
-        self->priv->source = g_value_get_object (value);
-        break;
-
-      default:
-        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
-    }
-}
-
-static void
-bamf_tab_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec)
-{
-  BamfTab *self;
-
-  self = BAMF_TAB (object);
-
-  switch (property_id)
-    {
-      case PROP_ID:
-        g_value_set_string (value, self->priv->id);
-        break;
-
-      case PROP_SOURCE:
-        g_value_set_object (value, self->priv->source);
-        break;
-
-      default:
-        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
-    }
-}
-
-static void
-bamf_tab_constructed (GObject *object)
-{
-  BamfTab *self;
-
-  if (G_OBJECT_CLASS (bamf_tab_parent_class)->constructed)
-    G_OBJECT_CLASS (bamf_tab_parent_class)->constructed (object);
-
-  self = BAMF_TAB (object);
-
-  g_signal_connect (self->priv->source, "remote-tab-uri-changed",
-                    G_CALLBACK (on_tab_source_uri_changed), self);
+  
+  self = BAMF_TAB (object);
+  
+  switch (property_id)
+    {
+    case PROP_LOCATION:
+      if (self->priv->location != NULL)
+	{
+	  g_free (self->priv->location);
+	}
+      self->priv->location = g_value_dup_string (value);
+      bamf_dbus_item_tab_set_location (self->priv->dbus_iface, self->priv->location);
+
+      break;
+    case PROP_DESKTOP_ID:
+      if (self->priv->desktop_id != NULL)
+	{
+	  g_free (self->priv->desktop_id);
+	}
+      self->priv->desktop_id = g_value_dup_string (value);
+      bamf_dbus_item_tab_set_desktop_id (self->priv->dbus_iface, self->priv->desktop_id);
+      
+      break;
+    case PROP_XID:
+      self->priv->xid = g_value_get_uint64 (value);
+      bamf_dbus_item_tab_set_xid (self->priv->dbus_iface, self->priv->xid);
+
+      break;
+    case PROP_IS_FOREGROUND_TAB:
+      self->priv->is_foreground = g_value_get_boolean (value);
+      bamf_dbus_item_tab_set_is_foreground_tab (self->priv->dbus_iface, self->priv->is_foreground);
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
+    }
 }
 
 static void
 bamf_tab_dispose (GObject *object)
 {
-  BamfTab *self = BAMF_TAB (object);
-
-  if (self->priv->id)
-    {
-      g_free (self->priv->id);
-      self->priv->id = NULL;
-    }
-
-  if (self->priv->uri)
-    {
-      g_free (self->priv->uri);
-      self->priv->uri = NULL;
-    }
-
+  //  BamfTab *self = BAMF_TAB (object);
+  
   G_OBJECT_CLASS (bamf_tab_parent_class)->dispose (object);
 }
 
@@ -239,42 +134,89 @@
 {
   BamfTab *self = BAMF_TAB (object);
 
+  if (self->priv->location)
+    {
+      g_free (self->priv->location);
+    }
+  
+  if (self->priv->desktop_id)
+    {
+      g_free (self->priv->desktop_id);
+    }
+  
   g_object_unref (self->priv->dbus_iface);
-
+  
   G_OBJECT_CLASS (bamf_tab_parent_class)->finalize (object);
 }
 
-static void
-bamf_tab_init (BamfTab * self)
+
+static gboolean
+on_dbus_handle_raise (BamfDBusItemView *interface,
+		      GDBusMethodInvocation *invocation,
+		      BamfTab *self)
+{
+  bamf_tab_raise (self);
+  
+  g_dbus_method_invocation_return_value (invocation, NULL);
+  
+  return TRUE;
+}
+
+static gboolean
+on_dbus_handle_close (BamfDBusItemView *interface,
+		      GDBusMethodInvocation *invocation,
+		      BamfTab *self)
+{
+  bamf_tab_close (self);
+  
+  g_dbus_method_invocation_return_value (invocation, NULL);
+  
+  return TRUE;
+}
+
+static void
+bamf_tab_preview_ready (BamfTab *self,
+			const gchar *preview_data,
+			gpointer user_data)
+{
+  GDBusMethodInvocation *invocation;
+  
+  invocation = (GDBusMethodInvocation *)user_data;
+  
+  g_dbus_method_invocation_return_value (invocation, g_variant_new ("(s)", preview_data));
+}
+
+static gboolean
+on_dbus_handle_request_preview (BamfDBusItemView *interface,
+				GDBusMethodInvocation *invocation,
+				BamfTab *self)
+{
+  bamf_tab_request_preview (self, bamf_tab_preview_ready, invocation);
+  
+  return TRUE;
+}
+
+static void
+bamf_tab_init (BamfTab *self)
 {
   self->priv = BAMF_TAB_GET_PRIVATE (self);
-
-  /* Initializing the dbus interface */
+  
   self->priv->dbus_iface = bamf_dbus_item_tab_skeleton_new ();
-
-  /* We need to connect to the object own signals to redirect them to the dbus
-   * interface                                                                */
-  g_signal_connect (self, "uri-changed", G_CALLBACK (on_uri_changed), NULL);
-
-  /* Registering signal callbacks to reply to dbus method calls */
-  g_signal_connect (self->priv->dbus_iface, "handle-show-tab",
-                    G_CALLBACK (on_dbus_handle_show_tab), self);
-
-  g_signal_connect (self->priv->dbus_iface, "handle-parent-xid",
-                    G_CALLBACK (on_dbus_handle_parent_xid), self);
-
-  g_signal_connect (self->priv->dbus_iface, "handle-current-uri",
-                    G_CALLBACK (on_dbus_handle_current_uri), self);
-
-  g_signal_connect (self->priv->dbus_iface, "handle-preview",
-                    G_CALLBACK (on_dbus_handle_preview), self);
-
-  /* Setting the interface for the dbus object */
+  
+  g_signal_connect (self->priv->dbus_iface, "handle-raise",
+		    G_CALLBACK (on_dbus_handle_raise), self);
+  g_signal_connect (self->priv->dbus_iface, "handle-close",
+		    G_CALLBACK (on_dbus_handle_close), self);
+  g_signal_connect (self->priv->dbus_iface, "handle-request-preview",
+		    G_CALLBACK (on_dbus_handle_request_preview), self);
+  
   bamf_dbus_item_object_skeleton_set_tab (BAMF_DBUS_ITEM_OBJECT_SKELETON (self),
-                                          self->priv->dbus_iface);
+					  self->priv->dbus_iface);
 }
 
-static void bamf_tab_dbus_iface_init (BamfDBusItemTabIface *iface)
+
+static void
+bamf_tab_dbus_iface_init (BamfDBusItemTabIface *iface)
 {
 }
 
@@ -284,31 +226,86 @@
   GParamSpec *pspec;
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
   BamfViewClass *view_class = BAMF_VIEW_CLASS (klass);
-
-  object_class->constructed  = bamf_tab_constructed;
+  
   object_class->get_property = bamf_tab_get_property;
   object_class->set_property = bamf_tab_set_property;
-  object_class->dispose      = bamf_tab_dispose;
-  object_class->finalize     = bamf_tab_finalize;
-  view_class->view_type      = bamf_tab_get_view_type;
-
-  pspec = g_param_spec_string ("id", "id", "id", NULL, G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
-  g_object_class_install_property (object_class, PROP_ID, pspec);
-
-  pspec = g_param_spec_object ("source", "source", "source", BAMF_TYPE_TAB_SOURCE, G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
-  g_object_class_install_property (object_class, PROP_SOURCE, pspec);
-
+  object_class->dispose = bamf_tab_dispose;
+  object_class->finalize = bamf_tab_finalize;
+  view_class->view_type = bamf_tab_get_view_type;
+  
+  pspec = g_param_spec_string("location", "Location", "The Current location of the remote Tab",
+			      NULL, G_PARAM_READWRITE);
+  g_object_class_install_property (object_class, PROP_LOCATION, pspec);
+  
+  pspec = g_param_spec_string("desktop-id", "Desktop ID", "The Desktop ID assosciated with the application hosted in the remote Tab",
+			      NULL, G_PARAM_READWRITE);
+  g_object_class_install_property (object_class, PROP_DESKTOP_ID, pspec);
+  
+  pspec = g_param_spec_uint64("xid", "xid", "XID for the toplevel window containing the remote Tab",
+			      0, G_MAXUINT64, 0, G_PARAM_READWRITE);
+  g_object_class_install_property (object_class, PROP_XID, pspec);
+  
+  pspec = g_param_spec_boolean ("is-foreground-tab", "Foreground Tab", "Is this tab the foreground tab in it's toplevel container",
+			     FALSE, G_PARAM_READWRITE);
+  g_object_class_install_property (object_class, PROP_IS_FOREGROUND_TAB, pspec);
+  
+  
   g_type_class_add_private (klass, sizeof (BamfTabPrivate));
 }
 
-BamfTab *
-bamf_tab_new (BamfTabSource *source, const char *id)
-{
-  BamfTab *self;
-  self = (BamfTab *) g_object_new (BAMF_TYPE_TAB,
-                                   "source", source,
-                                   "id", id,
-                                   NULL);
-
-  return self;
+
+const gchar *
+bamf_tab_get_location (BamfTab *self)
+{
+  g_return_val_if_fail (BAMF_IS_TAB (self), NULL);
+
+  return self->priv->location;
+}
+
+const gchar *
+bamf_tab_get_desktop_id (BamfTab *self)
+{
+  g_return_val_if_fail (BAMF_IS_TAB (self), NULL);
+  
+  return self->priv->desktop_id;
+}
+
+guint64
+bamf_tab_get_xid (BamfTab *self)
+{
+  g_return_val_if_fail (BAMF_IS_TAB (self), 0);
+  
+  return self->priv->xid;
+}
+
+gboolean
+bamf_tab_get_is_foreground_tab (BamfTab *self)
+{
+  g_return_val_if_fail (BAMF_IS_TAB (self), 0);
+  
+  return self->priv->is_foreground;
+}
+
+void
+bamf_tab_raise (BamfTab *self)
+{
+  g_return_if_fail (BAMF_IS_TAB (self));
+  
+  BAMF_TAB_GET_CLASS (self)->raise (self);
+}
+
+void 
+bamf_tab_close (BamfTab *self)
+{
+  g_return_if_fail (BAMF_IS_TAB (self));
+  
+  BAMF_TAB_GET_CLASS (self)->close (self);
+}
+
+void 
+bamf_tab_request_preview (BamfTab *self, BamfTabPreviewReadyCallback callback, gpointer user_data)
+{
+  g_return_if_fail (BAMF_IS_TAB (self));
+  
+  BAMF_TAB_GET_CLASS (self)->request_preview (self, callback, user_data);
 }

=== modified file 'src/bamf-tab.h'
--- old/src/bamf-tab.h	2011-12-22 00:33:12 +0000
+++ new/src/bamf-tab.h	2012-08-10 17:56:37 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011 Canonical Ltd
+ * Copyright (C) 2010-2012 Canonical Ltd
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 3 as
@@ -13,9 +13,7 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
- * Authored by: Jason Smith <jason.smith@canonical.com>
- *              Marco Trevisan (Treviño) <3v1n0@ubuntu.com>
- *
+ * Authored by: Robert Carr <racarr@canonical.com>
  */
 
 #ifndef __BAMFTAB_H__
@@ -23,7 +21,6 @@
 
 #include "bamf.h"
 #include "bamf-view.h"
-#include "bamf-tab-source.h"
 #include <glib.h>
 #include <glib-object.h>
 
@@ -38,9 +35,15 @@
 typedef struct _BamfTabClass BamfTabClass;
 typedef struct _BamfTabPrivate BamfTabPrivate;
 
+typedef void (*BamfTabPreviewReadyCallback) (BamfTab *, const gchar *, gpointer);
+
 struct _BamfTabClass
 {
   BamfViewClass parent;
+  
+  void (*raise) (BamfTab *self);
+  void (*close) (BamfTab *self);
+  void (*request_preview) (BamfTab *self, BamfTabPreviewReadyCallback callback, gpointer user_data);
 };
 
 struct _BamfTab
@@ -53,14 +56,17 @@
 
 GType       bamf_tab_get_type    (void) G_GNUC_CONST;
 
-char      * bamf_tab_current_uri (BamfTab *self);
-
-void        bamf_tab_show        (BamfTab *self);
-
-guint32     bamf_tab_parent_xid  (BamfTab *tab);
-
-gchar     * bamf_tab_get_preview (BamfTab *tab);
-
-BamfTab   * bamf_tab_new         (BamfTabSource *source, const char *tab_id);
+const gchar *bamf_tab_get_desktop_id (BamfTab *self);
+const gchar *bamf_tab_current_location (BamfTab *self);
+guint64 bamf_tab_get_xid (BamfTab *self);
+gboolean bamf_tab_get_is_foreground_tab (BamfTab *self);
+
+
+void bamf_tab_raise (BamfTab *self);
+void bamf_tab_close (BamfTab *self);
+
+void bamf_tab_request_preview (BamfTab *self, BamfTabPreviewReadyCallback callback, gpointer user_data);
+
+
 
 #endif

=== added file 'src/bamf-unity-webapps-application.c'
--- old/src/bamf-unity-webapps-application.c	1970-01-01 00:00:00 +0000
+++ new/src/bamf-unity-webapps-application.c	2012-08-10 17:56:37 +0000
@@ -0,0 +1,365 @@
+/*
+ * Copyright (C) 2010-2011 Canonical Ltd
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANAPPLICATIONILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Authored by: 
+ *              Robert Carr <racarr@canonical.com>
+ *
+ */
+
+#include <stdlib.h>
+
+
+#include "bamf-unity-webapps-application.h"
+#include "bamf-unity-webapps-tab.h"
+#include "bamf-matcher.h"
+
+#include <unity-webapps-context.h>
+
+#define BAMF_UNITY_WEBAPPS_APPLICATION_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE(obj, \
+BAMF_TYPE_UNITY_WEBAPPS_APPLICATION, BamfUnityWebappsApplicationPrivate))
+
+G_DEFINE_TYPE(BamfUnityWebappsApplication, bamf_unity_webapps_application, BAMF_TYPE_APPLICATION);
+	
+enum
+{
+  PROP_0,
+  PROP_CONTEXT,
+};
+
+/*enum
+{
+  VANISHED,
+  LAST_SIGNAL
+};
+
+static guint unity_webapps_application_signals[LAST_SIGNAL] = { 0 };*/
+
+struct _BamfUnityWebappsApplicationPrivate
+{
+  UnityWebappsContext *context;
+};
+
+
+static void
+bamf_unity_webapps_application_get_application_menu (BamfApplication *application,
+						     gchar **name, 
+						     gchar **path)
+{
+  BamfUnityWebappsApplication *self;
+  
+  self = (BamfUnityWebappsApplication *)application;
+  
+  *name = g_strdup (unity_webapps_context_get_context_name (self->priv->context));
+  *path = g_strdup ("/com/canonical/Unity/Webapps/Context/ApplicationActions");
+}
+
+static void
+bamf_unity_webapps_application_get_property (GObject *object, guint property_id, GValue *gvalue, GParamSpec *pspec)
+{
+  BamfUnityWebappsApplication *self;
+  
+  self = BAMF_UNITY_WEBAPPS_APPLICATION (object);
+  
+  switch (property_id)
+    {
+    case PROP_CONTEXT:
+      g_value_set_object (gvalue, self->priv->context);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    }
+}
+
+static BamfUnityWebappsTab *
+bamf_unity_webapps_application_find_child_by_interest (BamfUnityWebappsApplication *application,
+						       gint interest_id)
+{
+  GList *children, *walk;
+  BamfUnityWebappsTab *child;
+  
+  children = bamf_view_get_children (BAMF_VIEW (application));
+  
+  for (walk = children; walk != NULL; walk = walk->next)
+    {
+      child = BAMF_UNITY_WEBAPPS_TAB (walk->data);
+      
+      if (interest_id == bamf_unity_webapps_tab_get_interest_id (child))
+	{
+	  return child;
+	}
+    }
+  
+  return NULL;
+}
+
+static BamfView *
+bamf_unity_webapps_application_get_focus_child (BamfApplication *application)
+{
+  BamfUnityWebappsApplication *self;
+  gint focus_interest;
+  
+  self = BAMF_UNITY_WEBAPPS_APPLICATION (application);
+  
+  focus_interest = unity_webapps_context_get_focus_interest (self->priv->context);
+  
+  if (focus_interest == -1)
+    return NULL;
+
+  return (BamfView *)bamf_unity_webapps_application_find_child_by_interest (self, focus_interest);
+}
+
+
+static void
+bamf_unity_webapps_application_interest_appeared (UnityWebappsContext *context,
+						  gint interest_id,
+						  gpointer user_data)
+{
+  BamfUnityWebappsApplication *self;
+  BamfView *interest_view;
+  BamfUnityWebappsTab *child;
+  
+  self = (BamfUnityWebappsApplication *)user_data;
+
+  child = bamf_unity_webapps_application_find_child_by_interest (self, interest_id);
+  
+  if (child != NULL)
+    {
+      return;
+    }
+  
+  interest_view = (BamfView *)bamf_unity_webapps_tab_new (context, interest_id);
+  
+  bamf_view_add_child (BAMF_VIEW (self), interest_view);
+  
+  // It's possible that the context had become lonely (i.e. no children) but not yet shut down.
+  // however, if we gain an interest we are always running and "mapped".
+  
+  bamf_view_set_running (BAMF_VIEW (self), TRUE);
+  bamf_view_set_user_visible (BAMF_VIEW (self), TRUE);
+}
+
+static void
+bamf_unity_webapps_application_interest_vanished (UnityWebappsContext *context,
+						  gint interest_id,
+						  gpointer user_data)
+{
+  BamfUnityWebappsApplication *self;
+  BamfUnityWebappsTab *child;
+  
+  self = (BamfUnityWebappsApplication *)user_data;
+  
+  child = bamf_unity_webapps_application_find_child_by_interest (self, interest_id);
+  
+  if (child == NULL)
+    {
+      return;
+    }
+  
+  bamf_view_remove_child (BAMF_VIEW (self), BAMF_VIEW (child));
+}
+
+/* It doesn't make any sense for a BamfUnityWebappsTab to live without it's assosciated context.
+ * so when our children are removed, dispose of them. */
+static void
+bamf_unity_webapps_application_child_removed (BamfView *view, BamfView *child)
+{
+  // Chain up first before we destroy the object.
+  BAMF_VIEW_CLASS (bamf_unity_webapps_application_parent_class)->child_removed (view, child);
+
+  bamf_view_set_running (child, FALSE);
+  bamf_view_close (BAMF_VIEW (child));
+  g_object_unref (BAMF_VIEW (child));
+}
+
+/* 
+ * As soon as we have a tab, we wan't to export it on the bus. We want to make sure tabs are registered with 
+ * the matcher, after the application is added, so we do the registration here rather than
+ * inside BamfUnityWebappsTab 
+ */
+static void
+bamf_unity_webapps_application_child_added (BamfView *view, BamfView *child)
+{
+  bamf_matcher_register_view_stealing_ref (bamf_matcher_get_default (), child);
+  
+  BAMF_VIEW_CLASS (bamf_unity_webapps_application_parent_class)->child_added (view, child);
+}
+
+static void
+bamf_unity_webapps_application_add_existing_interests (BamfUnityWebappsApplication *self)
+{
+  GVariant *interests, *interest_variant;
+  GVariantIter *variant_iter;
+  
+  interests = unity_webapps_context_list_interests (self->priv->context);
+  
+  if (interests == NULL)
+    {
+      return;
+    }
+  
+  variant_iter = g_variant_iter_new (interests);
+  
+  while ((interest_variant = g_variant_iter_next_value (variant_iter)))
+    {
+      gint interest_id;
+      
+      interest_id = g_variant_get_int32 (interest_variant);
+      
+      bamf_unity_webapps_application_interest_appeared (self->priv->context, interest_id, self);
+    }
+}
+
+static void
+bamf_unity_webapps_application_context_set (BamfUnityWebappsApplication *self)
+{
+  gchar *desktop_file = g_strdup_printf("%s/.local/share/applications/%s", g_get_home_dir (), unity_webapps_context_get_desktop_name (self->priv->context));
+  gchar *wmclass = g_strdup_printf("unity-webapps-%p", self);
+  
+  bamf_application_set_desktop_file (BAMF_APPLICATION (self), desktop_file);
+
+  // TODO: Currently we just put something unique here so the matcher wont get confused within the span of a single run. It's a little
+  // meaningless however...is there something useful we can put here? If not, how can we prevent the matcher from becoming confused
+  // when nothing is here.
+  bamf_application_set_wmclass (BAMF_APPLICATION (self), wmclass);
+
+  // Sometimes we might have no children for a short period (for example, the page is reloading), in the case
+  // Unity Webapps will keep the context alive for a while. Allowing for new children to appear...before eventually
+  // shutting it down. So we use this flag to ensure BAMF will not shut us down prematurely.
+  bamf_application_set_close_when_empty (BAMF_APPLICATION (self), FALSE);
+  
+  bamf_matcher_register_view_stealing_ref (bamf_matcher_get_default (), BAMF_VIEW (self));
+  
+  bamf_unity_webapps_application_add_existing_interests (self);
+  
+  unity_webapps_context_on_interest_appeared (self->priv->context, bamf_unity_webapps_application_interest_appeared, self);
+  unity_webapps_context_on_interest_vanished (self->priv->context, bamf_unity_webapps_application_interest_vanished, self);
+  
+  g_free (wmclass);  
+  g_free (desktop_file);
+}
+
+static void
+bamf_unity_webapps_application_set_property (GObject *object, guint property_id, const GValue *gvalue, GParamSpec *pspec)
+{
+  BamfUnityWebappsApplication *self;
+  
+  self = BAMF_UNITY_WEBAPPS_APPLICATION (object);
+  
+  switch (property_id)
+    {
+    case PROP_CONTEXT:
+      g_assert (self->priv->context == NULL);
+      self->priv->context = g_value_get_object (gvalue);
+      
+      bamf_unity_webapps_application_context_set (self);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
+    }
+}
+
+static gchar *
+bamf_unity_webapps_application_get_stable_bus_name (BamfView *view)
+{
+  return g_strdup_printf ("application%i", abs (g_str_hash (bamf_application_get_desktop_file (BAMF_APPLICATION (view)))));
+}
+
+
+static void
+bamf_unity_webapps_application_dispose (GObject *object)
+{
+  //  BamfUnityWebappsApplication *self = BAMF_UNITY_WEBAPPS_APPLICATION (object);
+
+  G_OBJECT_CLASS (bamf_unity_webapps_application_parent_class)->dispose (object);
+}
+
+static void
+bamf_unity_webapps_application_finalize (GObject *object)
+{
+  BamfUnityWebappsApplication *self = BAMF_UNITY_WEBAPPS_APPLICATION (object);
+
+  g_object_unref (self->priv->context);
+
+  G_OBJECT_CLASS (bamf_unity_webapps_application_parent_class)->finalize (object);
+}
+
+static void
+on_accept_data_changed (UnityWebappsContext *context, const gchar **file, gpointer user_data)
+{
+  BamfUnityWebappsApplication *self = BAMF_UNITY_WEBAPPS_APPLICATION (user_data);
+
+  bamf_application_emit_dnd_mimes_changed (BAMF_APPLICATION (self));
+}
+
+
+static void
+bamf_unity_webapps_application_init (BamfUnityWebappsApplication *self)
+{
+  self->priv = BAMF_UNITY_WEBAPPS_APPLICATION_GET_PRIVATE (self);
+
+  bamf_application_set_application_type (BAMF_APPLICATION (self), "webapp");
+
+  g_signal_connect (self->priv->context, "accept-data-changed", G_CALLBACK (on_accept_data_changed), self);
+}
+
+static char **
+bamf_unity_webapps_application_get_dnd_mimes (BamfApplication *application)
+{
+  BamfUnityWebappsApplication *self = BAMF_UNITY_WEBAPPS_APPLICATION (application);
+
+  return unity_webapps_context_get_application_accept_data (self->priv->context);
+}
+
+static void
+bamf_unity_webapps_application_class_init (BamfUnityWebappsApplicationClass * klass)
+{
+  GParamSpec *pspec;
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  BamfApplicationClass *bamf_application_class = BAMF_APPLICATION_CLASS (klass);
+  BamfViewClass *bamf_view_class = BAMF_VIEW_CLASS (klass);
+  
+  object_class->get_property = bamf_unity_webapps_application_get_property;
+  object_class->set_property = bamf_unity_webapps_application_set_property;
+  object_class->dispose = bamf_unity_webapps_application_dispose;
+  object_class->finalize = bamf_unity_webapps_application_finalize;
+  
+  bamf_view_class->stable_bus_name = bamf_unity_webapps_application_get_stable_bus_name;
+  bamf_view_class->child_removed = bamf_unity_webapps_application_child_removed;
+  bamf_view_class->child_added = bamf_unity_webapps_application_child_added;
+  
+  bamf_application_class->get_application_menu = bamf_unity_webapps_application_get_application_menu;
+  bamf_application_class->get_focus_child = bamf_unity_webapps_application_get_focus_child;
+  bamf_application_class->get_dnd_mimes = bamf_unity_webapps_application_get_dnd_mimes;
+  
+  pspec = g_param_spec_object("context", "Context", "The Unity Webapps Context assosciated with the Application",
+			      UNITY_WEBAPPS_TYPE_CONTEXT, G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY);
+  g_object_class_install_property (object_class, PROP_CONTEXT, pspec);
+  
+  
+  g_type_class_add_private (klass, sizeof (BamfUnityWebappsApplicationPrivate));
+}
+
+
+BamfApplication *
+bamf_unity_webapps_application_new (UnityWebappsContext *context)
+{
+  return (BamfApplication *)g_object_new (BAMF_TYPE_UNITY_WEBAPPS_APPLICATION, "context", context, NULL);
+}
+
+UnityWebappsContext *
+bamf_unity_webapps_application_get_context (BamfUnityWebappsApplication *application)
+{
+  return application->priv->context;
+}

=== added file 'src/bamf-unity-webapps-application.h'
--- old/src/bamf-unity-webapps-application.h	1970-01-01 00:00:00 +0000
+++ new/src/bamf-unity-webapps-application.h	2012-08-10 17:56:37 +0000
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2010-2011 Canonical Ltd
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANAPPLICATIONILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Authored by: Jason Smith <jason.smith@canonical.com>
+ *              Marco Trevisan (Treviño) <3v1n0@ubuntu.com>
+ *
+ */
+
+#ifndef __BAMF_UNITY_WEBAPPS_APPLICATION_H__
+#define __BAMF_UNITY_WEBAPPS_APPLICATION_H__
+
+#include <unity-webapps-context.h>
+
+#include "bamf-application.h"
+
+
+#define BAMF_TYPE_UNITY_WEBAPPS_APPLICATION			(bamf_unity_webapps_application_get_type ())
+#define BAMF_UNITY_WEBAPPS_APPLICATION(obj)			(G_TYPE_CHECK_INSTANCE_CAST ((obj), BAMF_TYPE_UNITY_WEBAPPS_APPLICATION, BamfUnityWebappsApplication))
+#define BAMF_IS_UNITY_WEBAPPS_APPLICATION(obj)		(G_TYPE_CHECK_INSTANCE_TYPE ((obj), BAMF_TYPE_UNITY_WEBAPPS_APPLICATION))
+#define BAMF_UNITY_WEBAPPS_APPLICATION_CLASS(klass)		(G_TYPE_CHECK_CLASS_CAST ((klass), BAMF_TYPE_UNITY_WEBAPPS_APPLICATION, BamfUnityWebappsApplicationClass))
+#define BAMF_IS_UNITY_WEBAPPS_APPLICATION_CLASS(klass)	(G_TYPE_CHECK_CLASS_TYPE ((klass), BAMF_TYPE_UNITY_WEBAPPS_APPLICATION))
+#define BAMF_UNITY_WEBAPPS_APPLICATION_GET_CLASS(obj)		(G_TYPE_INSTANCE_GET_CLASS ((obj), BAMF_TYPE_UNITY_WEBAPPS_APPLICATION, BamfUnityWebappsUnityWebappsApplicationClass))
+
+typedef struct _BamfUnityWebappsApplication BamfUnityWebappsApplication;
+typedef struct _BamfUnityWebappsApplicationClass BamfUnityWebappsApplicationClass;
+typedef struct _BamfUnityWebappsApplicationPrivate BamfUnityWebappsApplicationPrivate;
+
+struct _BamfUnityWebappsApplicationClass
+{
+  BamfApplicationClass parent;
+};
+
+struct _BamfUnityWebappsApplication
+{
+  BamfApplication parent;
+
+  /* private */
+  BamfUnityWebappsApplicationPrivate *priv;
+};
+
+GType       bamf_unity_webapps_application_get_type    (void) G_GNUC_CONST;
+
+BamfApplication *bamf_unity_webapps_application_new (UnityWebappsContext *context);
+UnityWebappsContext *bamf_unity_webapps_application_get_context (BamfUnityWebappsApplication *application);
+
+
+
+#endif

=== added file 'src/bamf-unity-webapps-observer.c'
--- old/src/bamf-unity-webapps-observer.c	1970-01-01 00:00:00 +0000
+++ new/src/bamf-unity-webapps-observer.c	2012-08-10 17:56:37 +0000
@@ -0,0 +1,240 @@
+/*
+ * bamf-unity-webapps-observer.c
+ * Copyright (C) Canonical LTD 2012
+ *
+ * Author: Robert Carr <racarr@canonical.com>
+ * 
+ unity-webapps is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * unity-webapps is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.";
+ */
+
+#include "bamf-unity-webapps-tab.h"
+#include "bamf-unity-webapps-observer.h"
+#include "bamf-unity-webapps-application.h"
+#include "bamf-matcher.h"
+
+struct _BamfUnityWebappsObserverPrivate {
+  UnityWebappsService *service;
+  
+  GHashTable *applications_by_context_name;
+
+  guint service_watch_id;
+};
+
+G_DEFINE_TYPE(BamfUnityWebappsObserver, bamf_unity_webapps_observer, G_TYPE_OBJECT)
+
+
+#define BAMF_UNITY_WEBAPPS_OBSERVER_GET_PRIVATE(object) (G_TYPE_INSTANCE_GET_PRIVATE ((object), BAMF_TYPE_UNITY_WEBAPPS_OBSERVER, BamfUnityWebappsObserverPrivate))
+
+static void
+bamf_unity_webapps_observer_context_vanished (UnityWebappsService *service,
+					     const gchar *name,
+					     gpointer user_data)
+{
+  BamfUnityWebappsObserver *observer;
+  BamfApplication *application;
+  
+  observer = (BamfUnityWebappsObserver *)user_data;
+  
+  application = g_hash_table_lookup (observer->priv->applications_by_context_name, name);
+  
+  if (application == NULL)
+    return;
+  
+  bamf_view_set_running (BAMF_VIEW (application), FALSE);
+  bamf_view_close (BAMF_VIEW (application));
+  
+  g_hash_table_remove (observer->priv->applications_by_context_name, name);
+  
+}
+
+static void 
+bamf_unity_webapps_application_closed (BamfView *view,
+				       gpointer user_data)
+{
+  BamfUnityWebappsObserver *observer;
+  BamfUnityWebappsApplication *application;
+  UnityWebappsContext *context;
+  const gchar *context_name;
+  
+  observer = (BamfUnityWebappsObserver *)user_data;
+  
+  application = BAMF_UNITY_WEBAPPS_APPLICATION (view);
+  
+  context = bamf_unity_webapps_application_get_context  (application);
+  context_name = unity_webapps_context_get_context_name (context);
+  
+  g_hash_table_remove (observer->priv->applications_by_context_name, context_name);
+  
+  g_object_unref (G_OBJECT (view));
+}
+
+static void
+bamf_unity_webapps_observer_context_appeared (UnityWebappsService *service,
+					      const gchar *name,
+					      gpointer user_data)
+{
+  BamfUnityWebappsObserver *observer;
+  UnityWebappsContext *context;
+  BamfApplication *application;
+
+  if (name[0] == '\0')
+    return;
+
+  observer = (BamfUnityWebappsObserver *)user_data;
+
+  if (g_hash_table_lookup (observer->priv->applications_by_context_name, name) != NULL)
+    return;
+
+  context = unity_webapps_context_new_for_context_name (observer->priv->service, name);
+
+  application = bamf_unity_webapps_application_new (context);
+  
+  g_signal_connect (G_OBJECT (application), "closed-internal", G_CALLBACK (bamf_unity_webapps_application_closed),
+		    observer);
+
+  g_hash_table_insert (observer->priv->applications_by_context_name, g_strdup (name), application);
+}
+
+static void
+bamf_unity_webapps_observer_register_existing_contexts (BamfUnityWebappsObserver *observer,
+							UnityWebappsService *service)
+{
+  gchar **contexts;
+  gint i, len;
+  
+  contexts = unity_webapps_service_list_contexts (service);
+  
+  if (contexts == NULL)
+    return;
+  
+  len = g_strv_length (contexts);
+  
+  if (len == 0)
+    return;
+  
+  for (i = 0; i < len; i++)
+    {
+      bamf_unity_webapps_observer_context_appeared (service, contexts[i], observer);
+    }
+  
+  g_strfreev (contexts);
+}
+
+static void
+bamf_unity_webapps_observer_service_appeared (GDBusConnection *connection,
+					      const gchar *name,
+					      const gchar *name_owner,
+					      gpointer user_data)
+{
+  BamfUnityWebappsObserver *observer;
+  
+  observer = (BamfUnityWebappsObserver *)user_data;
+  
+  observer->priv->service = unity_webapps_service_new ();
+  
+  unity_webapps_service_on_context_appeared (observer->priv->service, bamf_unity_webapps_observer_context_appeared, observer);
+  unity_webapps_service_on_context_vanished (observer->priv->service, bamf_unity_webapps_observer_context_vanished, observer);
+
+  bamf_unity_webapps_observer_register_existing_contexts (observer, observer->priv->service);
+  
+}
+
+static void
+bamf_unity_webapps_observer_close_all (BamfUnityWebappsObserver *observer)
+{
+  GList *names, *walk;
+  
+  names = g_hash_table_get_keys (observer->priv->applications_by_context_name);
+  
+  for (walk = names; walk != NULL; walk = walk->next)
+    {
+      bamf_unity_webapps_observer_context_vanished (observer->priv->service, (const gchar *)walk->data,
+						    observer);
+    }
+  
+  g_list_free (names);
+  
+
+}
+
+static void
+bamf_unity_webapps_observer_service_vanished (GDBusConnection *connection,
+					      const gchar *name,
+					      gpointer user_data)
+{
+  BamfUnityWebappsObserver *observer;
+  observer = (BamfUnityWebappsObserver *)user_data;
+
+  if (observer->priv->service == NULL)
+    {
+      return;
+    }
+  
+  bamf_unity_webapps_observer_close_all (observer);  
+  
+  g_object_unref (G_OBJECT (observer->priv->service));
+  observer->priv->service = NULL;
+}
+
+static void
+bamf_unity_webapps_observer_finalize (GObject *object)
+{
+  BamfUnityWebappsObserver *observer;
+  
+  observer = BAMF_UNITY_WEBAPPS_OBSERVER (object);
+  
+  g_hash_table_destroy (observer->priv->applications_by_context_name);
+  
+  g_bus_unwatch_name (observer->priv->service_watch_id);
+  
+  g_object_unref (G_OBJECT (observer->priv->service));
+  
+  G_OBJECT_CLASS (bamf_unity_webapps_observer_parent_class)->finalize (object);
+}
+
+static void
+bamf_unity_webapps_observer_class_init (BamfUnityWebappsObserverClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  
+  object_class->finalize = bamf_unity_webapps_observer_finalize;
+  
+  g_type_class_add_private (object_class, sizeof(BamfUnityWebappsObserverPrivate));
+  
+}
+
+static void
+bamf_unity_webapps_observer_init (BamfUnityWebappsObserver *observer)
+{
+  observer->priv = BAMF_UNITY_WEBAPPS_OBSERVER_GET_PRIVATE (observer);
+  
+  observer->priv->service = NULL;
+  
+  observer->priv->service_watch_id = g_bus_watch_name (G_BUS_TYPE_SESSION,
+						       "com.canonical.Unity.Webapps.Service",
+						       G_BUS_NAME_WATCHER_FLAGS_NONE,
+						       bamf_unity_webapps_observer_service_appeared,
+						       bamf_unity_webapps_observer_service_vanished,
+						       observer, NULL /* User data free func */);
+  
+  observer->priv->applications_by_context_name = g_hash_table_new_full (g_str_hash, g_str_equal,
+									g_free, NULL);
+}
+
+BamfUnityWebappsObserver *
+bamf_unity_webapps_observer_new ()
+{
+  return g_object_new (BAMF_TYPE_UNITY_WEBAPPS_OBSERVER, NULL);
+}
+

=== added file 'src/bamf-unity-webapps-observer.h'
--- old/src/bamf-unity-webapps-observer.h	1970-01-01 00:00:00 +0000
+++ new/src/bamf-unity-webapps-observer.h	2012-08-10 17:56:37 +0000
@@ -0,0 +1,54 @@
+/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
+/*
+ * bamf-unity-webapps-observer.h
+ * Copyright (C) Canonical LTD 2011
+ * 
+ * Author: Robert Carr <racarr@canonical.com>
+ * 
+unity-webapps is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * unity-webapps is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.";
+ */
+
+
+#ifndef __BAMF_UNITY_WEBAPPS_OBSERVER_H
+#define __BAMF_UNITY_WEBAPPS_OBSERVER_H
+
+
+#define BAMF_TYPE_UNITY_WEBAPPS_OBSERVER              (bamf_unity_webapps_observer_get_type())
+#define BAMF_UNITY_WEBAPPS_OBSERVER(obj)              (G_TYPE_CHECK_INSTANCE_CAST((obj), BAMF_TYPE_UNITY_WEBAPPS_OBSERVER, BamfUnityWebappsObserver))
+#define BAMF_UNITY_WEBAPPS_OBSERVER_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST((klass), BAMF_TYPE_UNITY_WEBAPPS_OBSERVER, BamfUnityWebappsObserverClass))
+#define BAMF_IS_UNITY_WEBAPPS_OBSERVER(obj)           (G_TYPE_CHECK_INSTANCE_TYPE((obj), BAMF_TYPE_UNITY_WEBAPPS_OBSERVER))
+#define BAMF_IS_UNITY_WEBAPPS_OBSERVER_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), BAMF_TYPE_UNITY_WEBAPPS_OBSERVER))
+#define BAMF_UNITY_WEBAPPS_OBSERVER_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS((obj), BAMF_TYPE_UNITY_WEBAPPS_OBSERVER, BamfUnityWebappsObserverClass))
+
+typedef struct _BamfUnityWebappsObserverPrivate BamfUnityWebappsObserverPrivate;
+typedef struct _BamfUnityWebappsObserverClass BamfUnityWebappsObserverClass;
+typedef struct _BamfUnityWebappsObserver BamfUnityWebappsObserver;
+
+
+struct _BamfUnityWebappsObserver {
+	GObject object;
+
+	BamfUnityWebappsObserverPrivate *priv;
+};
+
+
+struct _BamfUnityWebappsObserverClass {
+	GObjectClass parent_class;
+};
+
+GType bamf_unity_webapps_observer_get_type (void) G_GNUC_CONST;
+
+BamfUnityWebappsObserver *bamf_unity_webapps_observer_new ();
+
+#endif

=== added file 'src/bamf-unity-webapps-tab.c'
--- old/src/bamf-unity-webapps-tab.c	1970-01-01 00:00:00 +0000
+++ new/src/bamf-unity-webapps-tab.c	2012-08-10 17:56:37 +0000
@@ -0,0 +1,413 @@
+/*
+ * Copyright (C) 2010-2011 Canonical Ltd
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Authored by: 
+ *              Robert Carr <racarr@canonical.com>
+ *
+ */
+
+#include "bamf-unity-webapps-tab.h"
+#include "bamf-matcher.h"
+
+#include "bamf-xutils.h"
+#include "bamf-legacy-window.h"
+#include "bamf-legacy-screen.h"
+
+#include <unity-webapps-service.h>
+#include <unity-webapps-context.h>
+
+#define BAMF_UNITY_WEBAPPS_TAB_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE(obj, \
+BAMF_TYPE_UNITY_WEBAPPS_TAB, BamfUnityWebappsTabPrivate))
+
+G_DEFINE_TYPE(BamfUnityWebappsTab, bamf_unity_webapps_tab, BAMF_TYPE_TAB);
+	
+enum
+{
+  PROP_0,
+  PROP_CONTEXT,
+  PROP_INTEREST_ID
+};
+
+enum
+{
+  VANISHED,
+  LAST_SIGNAL
+};
+
+static guint unity_webapps_tab_signals[LAST_SIGNAL] = { 0 };
+
+struct _BamfUnityWebappsTabPrivate
+{
+  UnityWebappsContext *context;
+  
+  gint interest_id;
+  
+  BamfLegacyWindow *legacy_window;
+  
+  gboolean tab_active;
+};
+
+static void
+bamf_unity_webapps_tab_ensure_flags (BamfUnityWebappsTab *self)
+{
+  gboolean window_active;
+
+  // If we don't have a toplevel window assosciated with UnityWebappsContext
+  // determine if it's active. Safer to go with no.
+  if (self->priv->legacy_window == NULL)
+    {
+      bamf_view_set_active (BAMF_VIEW (self), FALSE);
+      return;
+    }
+  
+  window_active = bamf_legacy_window_is_active (self->priv->legacy_window);
+  
+  bamf_view_set_active (BAMF_VIEW (self), window_active && self->priv->tab_active);
+}
+
+static void
+bamf_unity_webapps_tab_active_window_changed (BamfLegacyScreen *screen, BamfUnityWebappsTab *tab)
+{
+  bamf_unity_webapps_tab_ensure_flags (tab);
+}
+
+static void
+bamf_unity_webapps_tab_create_bamf_window (BamfUnityWebappsTab *self,
+					   gulong xid)
+{
+  if (xid == 0)
+    return;
+  if (self->priv->legacy_window != NULL)
+    g_object_unref (G_OBJECT (self->priv->legacy_window));
+  self->priv->legacy_window = bamf_legacy_window_new (wnck_window_get (xid));
+}
+
+
+static void
+bamf_unity_webapps_tab_vanished (BamfUnityWebappsTab *self,
+					  gpointer user_data)
+{
+  self->priv->interest_id = -1;
+  self->priv->context = NULL;
+}
+
+static void
+bamf_unity_webapps_tab_location_changed (UnityWebappsContext *context,
+					 gint interest_id,
+					 const gchar *location,
+					 gpointer user_data)
+{
+  BamfUnityWebappsTab *self;
+  
+  self = (BamfUnityWebappsTab *)user_data;
+  
+  if ((self->priv->interest_id != interest_id) || (self->priv->interest_id == -1))
+    {
+      return;
+    }
+  
+  g_object_set (self, "location", location, NULL);
+}
+
+static void
+bamf_unity_webapps_tab_window_changed (UnityWebappsContext *context,
+				       gint interest_id,
+				       guint64 xid,
+				       gpointer user_data)
+{
+  BamfUnityWebappsTab *self;
+  
+  self = (BamfUnityWebappsTab *)user_data;
+  
+  if ((self->priv->interest_id != interest_id) || (self->priv->interest_id == -1))
+    {
+      return;
+    }
+  
+  g_object_set (self, "xid", xid, NULL);
+  
+  bamf_unity_webapps_tab_create_bamf_window (self, xid);
+  bamf_unity_webapps_tab_ensure_flags (self);
+}
+
+/*
+ * The activity signal from unity-webapps signifies the visibility of the tab WITHIN its toplevel XID.
+ * we have to mask this with window activity.
+ */
+static void
+bamf_unity_webapps_tab_active_changed (UnityWebappsContext *context,
+				       gint interest_id,
+				       gboolean is_active,
+				       gpointer user_data)
+{
+  BamfUnityWebappsTab *self;
+  
+  self = (BamfUnityWebappsTab *)user_data;
+  
+  if ((self->priv->interest_id != interest_id) || (self->priv->interest_id == -1))
+    {
+      return;
+    }
+  
+  self->priv->tab_active = is_active;
+  bamf_unity_webapps_tab_ensure_flags (self);
+  
+  g_object_set (G_OBJECT (self), "is-foreground-tab", is_active, NULL);
+}
+
+static void
+bamf_unity_webapps_tab_initialize_properties (BamfUnityWebappsTab *self)
+{
+  gchar *location;
+  guint64 xid;
+  gboolean is_active;
+  
+  location = unity_webapps_context_get_view_location (self->priv->context, self->priv->interest_id);
+  xid = unity_webapps_context_get_view_window (self->priv->context, self->priv->interest_id);
+  is_active = unity_webapps_context_get_view_is_active (self->priv->context, self->priv->interest_id);
+  
+  g_object_set (self, "location", location, "xid", xid, NULL);
+  
+  self->priv->tab_active = is_active;
+  bamf_unity_webapps_tab_create_bamf_window (self, xid);
+  
+  bamf_unity_webapps_tab_ensure_flags (self);
+  
+  g_free (location);
+}
+
+
+static void
+bamf_unity_webapps_tab_interest_id_set (BamfUnityWebappsTab *self)
+{
+  unity_webapps_context_on_view_location_changed (self->priv->context, bamf_unity_webapps_tab_location_changed,
+						  self);
+  unity_webapps_context_on_view_window_changed (self->priv->context, bamf_unity_webapps_tab_window_changed,
+						self);
+  unity_webapps_context_on_view_is_active_changed (self->priv->context, bamf_unity_webapps_tab_active_changed,
+						   self);
+  
+  bamf_unity_webapps_tab_initialize_properties (self);
+
+  bamf_view_set_running (BAMF_VIEW (self), TRUE);
+  
+  // We don't really use user_visible here, it's not clear to me if we should or not. Maybe it could be used in stead of the internal
+  // tab is active flag...this would let Unity do the masking. Current behavior works well for the current way the pips are specced though.
+  bamf_view_set_user_visible (BAMF_VIEW (self), TRUE);
+}
+
+
+static void
+bamf_unity_webapps_tab_get_property (GObject *object, guint property_id, GValue *gvalue, GParamSpec *pspec)
+{
+  BamfUnityWebappsTab *self;
+  
+  self = BAMF_UNITY_WEBAPPS_TAB (object);
+  
+  switch (property_id)
+    {
+    case PROP_CONTEXT:
+      g_value_set_object (gvalue, self->priv->context);
+      break;
+    case PROP_INTEREST_ID:
+      g_value_set_int (gvalue, self->priv->interest_id);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    }
+}
+
+static void
+bamf_unity_webapps_tab_set_property (GObject *object, guint property_id, const GValue *gvalue, GParamSpec *pspec)
+{
+  BamfUnityWebappsTab *self;
+  
+  self = BAMF_UNITY_WEBAPPS_TAB (object);
+  
+  switch (property_id)
+    {
+    case PROP_CONTEXT:
+      g_assert (self->priv->context == NULL);
+      self->priv->context = g_value_get_object (gvalue);
+      self->priv->context = unity_webapps_context_new_for_context_name (unity_webapps_context_get_service (self->priv->context), 
+									unity_webapps_context_get_context_name (self->priv->context));
+      break;
+    case PROP_INTEREST_ID:
+      g_assert (self->priv->interest_id == 0);
+      self->priv->interest_id = g_value_get_int (gvalue);
+      bamf_unity_webapps_tab_interest_id_set (self);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
+    }
+}
+
+
+static void
+bamf_unity_webapps_tab_dispose (GObject *object)
+{
+  BamfUnityWebappsTab *self = BAMF_UNITY_WEBAPPS_TAB (object);
+  
+  g_signal_handlers_disconnect_by_func (bamf_legacy_screen_get_default (),
+					bamf_unity_webapps_tab_active_window_changed,
+					self);
+  
+  if (self->priv->legacy_window)
+    g_object_unref (G_OBJECT (self->priv->legacy_window));
+  
+  G_OBJECT_CLASS (bamf_unity_webapps_tab_parent_class)->dispose (object);
+}
+
+static void
+bamf_unity_webapps_tab_finalize (GObject *object)
+{
+  BamfUnityWebappsTab *self = BAMF_UNITY_WEBAPPS_TAB (object);
+  
+  g_object_unref (G_OBJECT (self->priv->context));
+  
+  G_OBJECT_CLASS (bamf_unity_webapps_tab_parent_class)->finalize (object);
+}
+
+static void
+bamf_unity_webapps_tab_init (BamfUnityWebappsTab *self)
+{
+  self->priv = BAMF_UNITY_WEBAPPS_TAB_GET_PRIVATE (self);
+  
+  self->priv->tab_active = FALSE;
+  self->priv->legacy_window = NULL;
+  
+  g_signal_connect (G_OBJECT (bamf_legacy_screen_get_default ()), "active-window-changed",
+		    (GCallback) bamf_unity_webapps_tab_active_window_changed, self);
+
+}
+
+static void
+bamf_unity_webapps_tab_raise (BamfTab *tab)
+{
+  BamfUnityWebappsTab *self = BAMF_UNITY_WEBAPPS_TAB (tab);
+
+  if (self->priv->interest_id == -1)
+    {
+      return;
+    }
+  
+  unity_webapps_context_raise_interest (self->priv->context, self->priv->interest_id);
+}
+
+static void
+bamf_unity_webapps_tab_close (BamfTab *tab)
+{
+  BamfUnityWebappsTab *self = BAMF_UNITY_WEBAPPS_TAB (tab);
+  
+  if (self->priv->interest_id == -1)
+    {
+      return;
+    }
+  
+  unity_webapps_context_close_interest (self->priv->context, self->priv->interest_id);
+}
+
+typedef struct _bamf_unity_webapps_preview_data {
+  BamfUnityWebappsTab *tab;
+  BamfTabPreviewReadyCallback callback;
+  gpointer user_data;
+} bamf_unity_webapps_preview_data;
+
+static void
+bamf_unity_webapps_tab_preview_ready (UnityWebappsContext *context, 
+				      gint interest_id,
+				      const gchar *preview_data,
+				      gpointer user_data)
+{
+  bamf_unity_webapps_preview_data *data;
+  
+  data = (bamf_unity_webapps_preview_data *)user_data;
+
+  data->callback ((BamfTab *)data->tab, preview_data, data->user_data);
+  
+  g_slice_free1 (sizeof (bamf_unity_webapps_preview_data), data);
+}
+
+static void
+bamf_unity_webapps_tab_request_preview (BamfTab *tab, 
+					BamfTabPreviewReadyCallback callback, 
+					gpointer user_data)
+{
+  BamfUnityWebappsTab *self;
+  bamf_unity_webapps_preview_data *data;
+  
+  self = BAMF_UNITY_WEBAPPS_TAB (tab);
+
+  data = g_slice_alloc0 (sizeof (bamf_unity_webapps_preview_data));
+  
+  data->tab = self;
+  data->callback = callback;
+  data->user_data = user_data;
+  
+  unity_webapps_context_request_preview (self->priv->context,
+					 self->priv->interest_id,
+					 bamf_unity_webapps_tab_preview_ready,
+					 data);  
+
+}
+
+static void
+bamf_unity_webapps_tab_class_init (BamfUnityWebappsTabClass * klass)
+{
+  GParamSpec *pspec;
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  BamfTabClass *bamf_tab_class = BAMF_TAB_CLASS (klass);
+  
+  object_class->get_property = bamf_unity_webapps_tab_get_property;
+  object_class->set_property = bamf_unity_webapps_tab_set_property;
+  object_class->dispose = bamf_unity_webapps_tab_dispose;
+  object_class->finalize = bamf_unity_webapps_tab_finalize;
+  
+  bamf_tab_class->raise = bamf_unity_webapps_tab_raise;
+  bamf_tab_class->close = bamf_unity_webapps_tab_close;
+  bamf_tab_class->request_preview = bamf_unity_webapps_tab_request_preview;
+  
+  pspec = g_param_spec_object("context", "Context", "The Unity Webapps Context assosciated with the Tab",
+			      UNITY_WEBAPPS_TYPE_CONTEXT, G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY);
+  g_object_class_install_property (object_class, PROP_CONTEXT, pspec);
+  
+  pspec = g_param_spec_int("interest-id", "Interest ID", "The Interest ID (unique to Context) for this Tab",
+			   G_MININT, G_MAXINT, -1, G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY);
+  g_object_class_install_property (object_class, PROP_INTEREST_ID, pspec);
+  
+  unity_webapps_tab_signals [VANISHED] =
+    g_signal_new_class_handler("vanished",
+			       G_OBJECT_CLASS_TYPE (klass),
+			       G_SIGNAL_RUN_FIRST,
+			       G_CALLBACK (bamf_unity_webapps_tab_vanished),
+			       NULL, NULL,
+			       g_cclosure_marshal_VOID__VOID,
+			       G_TYPE_NONE, 0);
+  
+  g_type_class_add_private (klass, sizeof (BamfUnityWebappsTabPrivate));
+}
+
+
+gint 
+bamf_unity_webapps_tab_get_interest_id (BamfUnityWebappsTab *tab)
+{
+  return tab->priv->interest_id;
+}
+
+BamfUnityWebappsTab *
+bamf_unity_webapps_tab_new (UnityWebappsContext *context, gint interest_id)
+{
+  return (BamfUnityWebappsTab *)g_object_new (BAMF_TYPE_UNITY_WEBAPPS_TAB, "context", context, "interest-id", interest_id, NULL);
+}

=== added file 'src/bamf-unity-webapps-tab.h'
--- old/src/bamf-unity-webapps-tab.h	1970-01-01 00:00:00 +0000
+++ new/src/bamf-unity-webapps-tab.h	2012-08-10 17:56:37 +0000
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2010-2011 Canonical Ltd
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Authored by: Jason Smith <jason.smith@canonical.com>
+ *              Marco Trevisan (Treviño) <3v1n0@ubuntu.com>
+ *
+ */
+
+#ifndef __BAMF_UNITY_WEBAPPS_TAB_H__
+#define __BAMF_UNITY_WEBAPPS_TAB_H__
+
+#include <unity-webapps-context.h>
+
+#include "bamf-tab.h"
+
+
+#define BAMF_TYPE_UNITY_WEBAPPS_TAB			(bamf_unity_webapps_tab_get_type ())
+#define BAMF_UNITY_WEBAPPS_TAB(obj)			(G_TYPE_CHECK_INSTANCE_CAST ((obj), BAMF_TYPE_UNITY_WEBAPPS_TAB, BamfUnityWebappsTab))
+#define BAMF_IS_UNITY_WEBAPPS_TAB(obj)		(G_TYPE_CHECK_INSTANCE_TYPE ((obj), BAMF_TYPE_UNITY_WEBAPPS_TAB))
+#define BAMF_UNITY_WEBAPPS_TAB_CLASS(klass)		(G_TYPE_CHECK_CLASS_CAST ((klass), BAMF_TYPE_UNITY_WEBAPPS_TAB, BamfUnityWebappsTabClass))
+#define BAMF_IS_UNITY_WEBAPPS_TAB_CLASS(klass)	(G_TYPE_CHECK_CLASS_TYPE ((klass), BAMF_TYPE_UNITY_WEBAPPS_TAB))
+#define BAMF_UNITY_WEBAPPS_TAB_GET_CLASS(obj)		(G_TYPE_INSTANCE_GET_CLASS ((obj), BAMF_TYPE_UNITY_WEBAPPS_TAB, BamfUnityWebappsUnityWebappsTabClass))
+
+typedef struct _BamfUnityWebappsTab BamfUnityWebappsTab;
+typedef struct _BamfUnityWebappsTabClass BamfUnityWebappsTabClass;
+typedef struct _BamfUnityWebappsTabPrivate BamfUnityWebappsTabPrivate;
+
+struct _BamfUnityWebappsTabClass
+{
+  BamfTabClass parent;
+};
+
+struct _BamfUnityWebappsTab
+{
+  BamfTab parent;
+
+  /* private */
+  BamfUnityWebappsTabPrivate *priv;
+};
+
+GType       bamf_unity_webapps_tab_get_type    (void) G_GNUC_CONST;
+
+BamfUnityWebappsTab *bamf_unity_webapps_tab_new (UnityWebappsContext *context, gint interest_id);
+
+gint bamf_unity_webapps_tab_get_interest_id (BamfUnityWebappsTab *tab);
+
+
+
+#endif

=== modified file 'src/org.ayatana.bamf.view.xml'
--- old/src/org.ayatana.bamf.view.xml	2012-02-15 05:45:13 +0000
+++ new/src/org.ayatana.bamf.view.xml	2012-08-10 17:56:37 +0000
@@ -69,15 +69,30 @@
     <method name="DesktopFile">
       <arg name="desktop_file" type="s" direction="out"/>
     </method>
+    <method name="DndMimes">
+      <arg name="dnd_mimes" type="as" direction="out"/>
+    </method>
     <method name="ApplicationType">
       <arg name="type" type="s" direction="out"/>
     </method>
+    <method name="ApplicationMenu">
+      <arg name="busname" type="s" direction="out"/>
+      <arg name="objectpath" type="s" direction="out"/>
+    </method>
+
+    <method name="FocusChild">
+      <arg name="path" type="s" direction="out"/>
+    </method>
+
     <signal name="WindowRemoved">
       <arg name="path" type="s"/>
     </signal>
     <signal name="WindowAdded">
       <arg name="path" type="s"/>
     </signal>
+    <signal name="DndMimesChanged">
+      <arg name="dnd_mimes" type="as"/>
+    </signal>
   </interface>
 
   <interface name="org.ayatana.bamf.window">
@@ -123,19 +138,16 @@
   </interface>
 
   <interface name="org.ayatana.bamf.tab">
-    <method name="ShowTab"/>
-    <method name="ParentXid">
-      <arg type="u" name="xid" direction="out"/>
-    </method>
-    <method name="CurrentUri">
-      <arg type="s" name="uri" direction="out"/>
-    </method>
-    <method name="Preview">
-      <arg type="ay" name="data" direction="out"/>
-    </method>
-    <signal name="UriChanged">
-      <arg type="s" name="old" direction="out"/>
-      <arg type="s" name="new" direction="out"/>
-    </signal>
+    <method name="Raise">
+    </method>
+    <method name="Close">
+    </method>
+    <method name="RequestPreview">
+      <arg type="s" name="data" direction="out"/>
+    </method>
+    <property name="location" type="s" access="read"/>
+    <property name="xid" type="t" access="read"/>
+    <property name="desktop-id" type="s" access="read"/>
+    <property name="is-foreground-tab" type="b" access="read"/>
   </interface>
 </node>

=== modified file 'tests/bamfdaemon/Makefile.am'
--- old/tests/bamfdaemon/Makefile.am	2012-08-01 13:56:43 +0000
+++ new/tests/bamfdaemon/Makefile.am	2012-08-10 17:56:37 +0000
@@ -14,7 +14,9 @@
 		$(top_srcdir)/src/bamf-application.c \
 		$(top_srcdir)/src/bamf-window.c \
 		$(top_srcdir)/src/bamf-tab.c \
-		$(top_srcdir)/src/bamf-tab-source.c \
+		$(top_srcdir)/src/bamf-unity-webapps-tab.c \
+		$(top_srcdir)/src/bamf-unity-webapps-observer.c \
+		$(top_srcdir)/src/bamf-unity-webapps-application.c \
 		$(top_srcdir)/src/bamf-indicator.c \
 		$(top_srcdir)/src/bamf-indicator-source.c \
 		$(top_srcdir)/src/bamf-xutils.c \
@@ -37,7 +39,6 @@
 		$(top_srcdir)/src/bamf-matcher.h \
 		$(top_srcdir)/src/bamf-window.h \
 		$(top_srcdir)/src/bamf-tab.h \
-		$(top_srcdir)/src/bamf-tab-source.h \
 		$(top_srcdir)/src/bamf-application.h \
 		$(top_srcdir)/src/bamf-indicator-source.h \
 		$(top_srcdir)/src/bamf-indicator.h \
@@ -69,6 +70,7 @@
   $(GLIB_CFLAGS) \
   $(WNCK_CFLAGS) \
   $(GTOP_CFLAGS) \
+  $(LIBUNITY_WEBAPPS_CFLAGS) \
   $(MAINTAINER_CFLAGS)
 
 test_bamf_LDADD = \
@@ -76,7 +78,8 @@
   $(GLIB_LIBS) \
   $(WNCK_LIBS) \
   $(GTOP_LIBS) \
-  $(GTK_LIBS)
+  $(GTK_LIBS) \
+  $(LIBUNITY_WEBAPPS_LIBS) 
 
 test_bamf_LDFLAGS = \
 		-Xlinker -export-dynamic -Wl,-O1 -Wl,-Bsymbolic-functions \

=== modified file 'tests/functional/Makefile.am'
--- old/tests/functional/Makefile.am	2012-01-19 20:29:47 +0000
+++ new/tests/functional/Makefile.am	2012-08-10 17:56:39 +0000
@@ -9,7 +9,6 @@
 noinst_PROGRAMS = \
   alt-tabber \
   desktop-file-launcher \
-  tab-source-test \
   interaction-tester
 
 # alt-tabber

